// === TOPDOWN CHAOS CARS ===
// Carros top-down com drift, boost, inimigos e tiro com rato.

import math;

var VIEW_W = 1280;
var VIEW_H = 720;
var WORLD_W = 3200;
var WORLD_H = 2400;

var KEY_W = 87;
var KEY_A = 65;
var KEY_S = 83;
var KEY_D = 68;
var KEY_UP = 265;
var KEY_LEFT = 263;
var KEY_DOWN = 264;
var KEY_RIGHT = 262;
var KEY_SPACE = 32;
var KEY_SHIFT = 340;
var KEY_R = 82;
var KEY_ESCAPE = 256;

var PLAYER_ID = -1;
var CAM_X = 0.0;
var CAM_Y = 0.0;
var GAME_OVER = false;
var SCORE = 0;
var KILLS = 0;
var HP_MAX = 10;
var HP = 10;
var ENEMIES_ALIVE = 0;

def clamp(v, lo, hi)
{
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
}

def fx_burst(px, py, n, r, g, b)
{
    var i = 0;
    while (i < n)
    {
        fx_particle(px, py, r, g, b);
        i += 1;
    }
}

process fx_particle(px, py, r, g, b)
{
    x = px;
    y = py;
    var a = math.rand(0, 360);
    var sp = math.rand(80, 320);
    var vx = get_distx(a, sp);
    var vy = get_disty(a, sp);
    var life = math.rand(0.10, 0.30);
    var max_life = life;
    var size = math.rand(2, 5);

    loop
    {
        var dt = delta();
        life -= dt;
        if (life <= 0) break;

        x += vx * dt;
        y += vy * dt;
        vy += 780 * dt;
        vx *= (1.0 - dt * 2.5);

        set_alpha(int(255 * (life / max_life)));
        set_color(r, g, b);
        draw_circle(x, y, size * (life / max_life), true);
        set_alpha(255);
        frame;
    }
}

process drift_mark(x1, y1, x2, y2)
{
    var life = 0.85;
    var max_life = life;
    var dx = x2 - x1;
    var dy = y2 - y1;
    var _len = sqrt(dx * dx + dy * dy);
    var nx = 0;
    var ny = 0;
    if (_len > 0.001)
    {
        nx = -dy / _len;
        ny = dx / _len;
    }

    loop
    {
        var dt = delta();
        life -= dt;
        if (life <= 0) break;

        var t = life / max_life;
        set_alpha(int(220 * t));
        set_color(48, 48, 56);
        draw_line(x1, y1, x2, y2);
        draw_line(x1 + nx, y1 + ny, x2 + nx, y2 + ny);
        draw_line(x1 - nx, y1 - ny, x2 - nx, y2 - ny);
        set_alpha(255);
        frame;
    }
}

def draw_backdrop(_camx, _camy)
{
    set_color(16, 20, 32);
    draw_rectangle(_camx, _camy, VIEW_W, VIEW_H, true);

    // Grid.
    set_color(30, 38, 56);
    var gx = int(_camx / 64) * 64;
    while (gx < _camx + VIEW_W + 64)
    {
        draw_line(gx, _camy, gx, _camy + VIEW_H);
        gx += 64;
    }
    var gy = int(_camy / 64) * 64;
    while (gy < _camy + VIEW_H + 64)
    {
        draw_line(_camx, gy, _camx + VIEW_W, gy);
        gy += 64;
    }

    // Quadras escuras para look de cidade.
    set_alpha(70);
    set_color(8, 10, 16);
    var bx = int(_camx / 320) * 320;
    while (bx < _camx + VIEW_W + 320)
    {
        var by = int(_camy / 240) * 240;
        while (by < _camy + VIEW_H + 240)
        {
            draw_rectangle(bx + 18, by + 18, 180, 120, true);
            by += 240;
        }
        bx += 320;
    }
    set_alpha(255);
}

process wall_block(px, py, w, h, r, g, b)
{
    x = px;
    y = py;

    set_rect_shape(0, 0, w, h);
    set_collision_layer(1);
    set_collision_mask(4);

    loop
    {
        set_color(r - 20, g - 20, b - 20);
        draw_rectangle(x - w / 2, y - h / 2, w, h, true);
        set_color(r, g, b);
        draw_rectangle(x - w / 2 + 2, y - h / 2 + 2, w - 4, h - 4, true);
        set_color(28, 34, 46);
        draw_rectangle(x - w / 2, y - h / 2, w, h, false);
        frame;
    }
}

process boost_pad(px, py)
{
    x = px;
    y = py;
    set_rect_shape(0, 0, 54, 30);
    set_collision_layer(3);
    set_collision_mask(0);

    loop
    {
        var t = time() * 8 + x * 0.02;
        var pulse = 0.5 + (sin(t) + 1) * 0.5;
        set_alpha(100 + int(pulse * 80));
        set_color(90, 180, 255);
        draw_rectangle(x - 27, y - 15, 54, 30, true);
        set_alpha(255);
        set_color(180, 230, 255);
        draw_rectangle(x - 21, y - 11, 42, 6, true);
        draw_rectangle(x - 21, y - 1, 42, 6, true);
        draw_rectangle(x - 21, y + 9, 42, 6, true);
        frame;
    }
}

process enemy_car(px, py)
{
    x = px;
    y = py;
    set_rect_shape(0, 0, 34, 20);
    set_collision_layer(2);
    set_collision_mask(2); // walls only (avoid car-to-car lock)

    var hp = 4;
    var touch_cd = 0.0;
    var hit_flash = 0.0;
    angle = math.rand(0, 360);
    velx = 0.0;
    vely = 0.0;

    loop
    {
        var dt = delta();

        if (GAME_OVER)
        {
            set_color(90, 95, 110);
            draw_rotated_rectangle(x - 17, y - 10, 34, 20, -angle, true);
            frame;
            continue;
        }

        if (touch_cd > 0) touch_cd -= dt;
        if (hit_flash > 0) hit_flash -= dt;

        if (state > 0)
        {
            hp -= state;
            state = 0;
            hit_flash = 0.12;
            fx_burst(x, y, 6, 255, 130, 130);
            if (hp <= 0)
            {
                KILLS += 1;
                SCORE += 30;
                ENEMIES_ALIVE -= 1;
                fx_burst(x, y, 16, 255, 170, 170);
                break;
            }
        }

        // IA: perseguicao + look-ahead para evitar paredes antes do impacto.
        var desired_turn = 0.0;
        var look_dist = 28 + clamp((abs(velx) + abs(vely)) * 0.05, 0, 18);
        var blocked_front = !place_free(x + get_distx(angle, look_dist),
                                        y + get_disty(angle, look_dist));
        var blocked_left = !place_free(x + get_distx(angle - 36, look_dist),
                                       y + get_disty(angle - 36, look_dist));
        var blocked_right = !place_free(x + get_distx(angle + 36, look_dist),
                                        y + get_disty(angle + 36, look_dist));

        var p = nil;
        if (PLAYER_ID != -1) p = proc(PLAYER_ID);
        if (p)
        {
            var target_a = get_angle(x, y, p.x, p.y);
            var d = target_a - angle;
            while (d > 180) d -= 360;
            while (d < -180) d += 360;
            desired_turn += clamp(d / 85, -1, 1);
        }

        if (blocked_front)
        {
            if (!blocked_left && blocked_right)
            {
                desired_turn += 1.0;
            }
            elif (!blocked_right && blocked_left)
            {
                desired_turn -= 1.0;
            }
            else
            {
                if (math.rand(0.0, 1.0) > 0.5) desired_turn += 1.0;
                else desired_turn -= 1.0;
            }

            // Trava/recuo leve para nao colar na parede.
            velx -= get_distx(angle, 260 * dt);
            vely -= get_disty(angle, 260 * dt);
        }
        else
        {
            // Se parede esta so de um lado, ja corrige antes de bater.
            if (blocked_left && !blocked_right) desired_turn -= 0.45;
            if (blocked_right && !blocked_left) desired_turn += 0.45;
        }

        var turn_speed = 150;
        if (blocked_front) turn_speed = 310;
        angle += desired_turn * turn_speed * dt;

        if (p)
        {
            var accel = 430;
            if (blocked_front) accel = 180;
            velx += get_distx(angle, accel * dt);
            vely += get_disty(angle, accel * dt);
        }

        // Drift/friction.
        var fx = get_distx(angle, 1);
        var fy = get_disty(angle, 1);
        var rx = get_distx(angle + 90, 1);
        var ry = get_disty(angle + 90, 1);
        var side = velx * rx + vely * ry;
        velx -= rx * side * math.min(1.0, dt * 6.0);
        vely -= ry * side * math.min(1.0, dt * 6.0);
        velx *= (1.0 - dt * 0.70);
        vely *= (1.0 - dt * 0.70);

        var moved_x = false;
        var moved_y = false;

        var nx = x + velx * dt;
        if (place_free(nx, y))
        {
            x = nx;
            moved_x = true;
        }
        else
        {
            var sx = math.sign(velx);
            var steps_x = 0;
            while (sx != 0 && steps_x < 28 && place_free(x + sx, y))
            {
                x += sx;
                steps_x += 1;
                moved_x = true;
            }
            velx *= -0.18;
        }

        var ny = y + vely * dt;
        if (place_free(x, ny))
        {
            y = ny;
            moved_y = true;
        }
        else
        {
            var sy = math.sign(vely);
            var steps_y = 0;
            while (sy != 0 && steps_y < 28 && place_free(x, y + sy))
            {
                y += sy;
                steps_y += 1;
                moved_y = true;
            }
            vely *= -0.18;
        }

        if (!moved_x && !moved_y)
        {
            velx *= 0.80;
            vely *= 0.80;
            // Unstuck: vira e recua um pouco para sair de cantos.
            if (math.rand(0.0, 1.0) > 0.5) angle += 180 * dt;
            else angle -= 180 * dt;
            velx -= get_distx(angle, 140 * dt);
            vely -= get_disty(angle, 140 * dt);
        }

        if (p && touch_cd <= 0 && get_dist(x, y, p.x, p.y) < 24)
        {
            p.state += 1;
            touch_cd = 0.6;
        }

        if (hit_flash > 0) set_color(255, 115, 135);
        else set_color(186, 82, 104);
        draw_rotated_rectangle(x - 17, y - 10, 34, 20, -angle, true);
        set_color(255, 220, 230);
        draw_rotated_rectangle(x - 11, y - 6, 14, 7, -angle, true);
        set_color(35, 20, 28);
        draw_rotated_rectangle(x - 17, y - 10, 34, 20, -angle, false);

        set_color(30, 18, 22);
        draw_rectangle(x - 12, y - 16, 24, 4, true);
        set_color(255, 120, 120);
        draw_rectangle(x - 12, y - 16, 24 * (hp / 4), 4, true);

        frame;
    }
}

process player_bullet(px, py, ang)
{
    x = px;
    y = py;
    set_circle_shape(4);
    set_collision_layer(4);
    set_collision_mask(0);

    var speed_b = 980;
    var life = 1.0;

    loop
    {
        var dt = delta();
        life -= dt;
        if (life <= 0) break;

        x += get_distx(ang, speed_b) * dt;
        y += get_disty(ang, speed_b) * dt;

        if (x < -40 || x > WORLD_W + 40 || y < -40 || y > WORLD_H + 40)
        {
            break;
        }

        var w = collision(type wall_block, x, y);
        if (w)
        {
            fx_burst(x, y, 5, 255, 210, 130);
            break;
        }

        var e = collision(type enemy_car, x, y);
        if (e)
        {
            e.state += 1;
            fx_burst(x, y, 8, 255, 225, 140);
            break;
        }

        set_alpha(90);
        set_color(255, 220, 120);
        draw_circle(x, y, 8, true);
        set_alpha(255);
        set_color(255, 245, 190);
        draw_circle(x, y, 4, true);
        frame;
    }
}

process player_car(px, py)
{
    x = px;
    y = py;
    xold = x;
    yold = y;

    set_rect_shape(0, 0, 36, 22);
    set_collision_layer(2);
    set_collision_mask(2); // walls only (enemy contact handled by distance)

    angle = -90;
    velx = 0.0;
    vely = 0.0;
    speed = 0.0;
    var fire_cd = 0.0;
    var hurt_cd = 0.0;
    var boost_cd = 0.0;
    var boost_t = 0.0;
    var trail_cd = 0.0;
    var skid_cd = 0.0;
    var wall_shake_cd = 0.0;

    loop
    {
        var dt = delta();
        xold = x;
        yold = y;
        var angle_old = angle;

        var mx = get_mouse_x() + CAM_X;
        var my = get_mouse_y() + CAM_Y;
        var aim = get_angle(x, y, mx, my);

        if (!GAME_OVER)
        {
            if (fire_cd > 0) fire_cd -= dt;
            if (hurt_cd > 0) hurt_cd -= dt;
            if (boost_cd > 0) boost_cd -= dt;
            if (boost_t > 0) boost_t -= dt;
            if (trail_cd > 0) trail_cd -= dt;
            if (skid_cd > 0) skid_cd -= dt;
            if (wall_shake_cd > 0) wall_shake_cd -= dt;

            var throttle = 0;
            if (key_down(KEY_W) || key_down(KEY_UP)) throttle += 1;
            if (key_down(KEY_S) || key_down(KEY_DOWN)) throttle -= 1;

            var steer = 0;
            if (key_down(KEY_A) || key_down(KEY_LEFT)) steer += 1;
            if (key_down(KEY_D) || key_down(KEY_RIGHT)) steer -= 1;

            var fx = get_distx(angle, 1);
            var fy = get_disty(angle, 1);
            var rx = get_distx(angle + 90, 1);
            var ry = get_disty(angle + 90, 1);
            var forward_v = velx * fx + vely * fy;
            var side_v = velx * rx + vely * ry;

            // Direcao do volante depende se vai para frente ou tras.
            var steer_dir = 1;
            if (forward_v < -8) steer_dir = -1;

            var turn_rate = 220;
            var speed_factor = clamp(abs(forward_v) / 420, 0.25, 1.2);
            angle += steer * steer_dir * turn_rate * speed_factor * dt;

            var accel = 650;
            if (throttle > 0) { velx += fx * accel * dt; vely += fy * accel * dt; }
            if (throttle < 0) { velx -= fx * (accel * 0.55) * dt; vely -= fy * (accel * 0.55) * dt; }

            if (key_pressed(KEY_SHIFT) && boost_cd <= 0)
            {
                boost_t = 0.24;
                boost_cd = 0.85;
                fx_burst(x, y, 10, 140, 220, 255);
                start_camera_shake(-2, -2, 24, 12);
            }
            if (boost_t > 0)
            {
                velx += fx * 1200 * dt;
                vely += fy * 1200 * dt;
            }

            // Grip/lateral damping (drift).
            var grip = 8.0;
            if (key_down(KEY_SPACE)) grip = 3.2; // handbrake drift
            velx -= rx * side_v * math.min(1.0, dt * grip);
            vely -= ry * side_v * math.min(1.0, dt * grip);

            // Drag.
            velx *= (1.0 - dt * 0.55);
            vely *= (1.0 - dt * 0.55);

            // Limites de velocidade.
            var maxf = 620;
            var maxr = 300;
            forward_v = velx * fx + vely * fy;
            if (forward_v > maxf)
            {
                var cut = (forward_v - maxf);
                velx -= fx * cut;
                vely -= fy * cut;
            }
            if (forward_v < -maxr)
            {
                var cut2 = (-maxr - forward_v);
                velx += fx * cut2;
                vely += fy * cut2;
            }

            var moved_x = false;
            var moved_y = false;

            var nx = x + velx * dt;
            if (place_free(nx, y))
            {
                x = nx;
                moved_x = true;
            }
            else
            {
                var hit_px = x + math.sign(velx) * 18;
                var hit_py = y + clamp(vely * 0.03, -8, 8);
                var hit_power = abs(velx) + abs(vely) * 0.30;

                var sx = math.sign(velx);
                var steps_x = 0;
                while (sx != 0 && steps_x < 34 && place_free(x + sx, y))
                {
                    x += sx;
                    steps_x += 1;
                    moved_x = true;
                }
                velx *= -0.18;
                fx_burst(hit_px, hit_py, 9, 255, 170, 120);
                if (wall_shake_cd <= 0 && hit_power > 110)
                {
                    start_camera_shake(-2, -2, 22, 9);
                    wall_shake_cd = 0.08;
                }
            }

            var ny = y + vely * dt;
            if (place_free(x, ny))
            {
                y = ny;
                moved_y = true;
            }
            else
            {
                var hit_px = x + clamp(velx * 0.03, -8, 8);
                var hit_py = y + math.sign(vely) * 11;
                var hit_power = abs(vely) + abs(velx) * 0.30;

                var sy = math.sign(vely);
                var steps_y = 0;
                while (sy != 0 && steps_y < 34 && place_free(x, y + sy))
                {
                    y += sy;
                    steps_y += 1;
                    moved_y = true;
                }
                vely *= -0.18;
                fx_burst(hit_px, hit_py, 9, 255, 170, 120);
                if (wall_shake_cd <= 0 && hit_power > 110)
                {
                    start_camera_shake(-2, -2, 22, 9);
                    wall_shake_cd = 0.08;
                }
            }

            if (!moved_x && !moved_y)
            {
                velx *= 0.78;
                vely *= 0.78;
            }

            // Marcas de drift (rodas traseiras), no mesmo referencial do debug.
            var drifting = (key_down(KEY_SPACE) || abs(side_v) > 42) && abs(forward_v) > 55;
            if (drifting && skid_cd <= 0)
            {
                skid_cd = 0.015;

                var rear_off = 14;
                var track = 8;
                var mark_angle_old = angle_old;
                var mark_angle_new = angle;

                var old_rx = xold + get_distx(mark_angle_old + 180, rear_off);
                var old_ry = yold + get_disty(mark_angle_old + 180, rear_off);
                var new_rx = x + get_distx(mark_angle_new + 180, rear_off);
                var new_ry = y + get_disty(mark_angle_new + 180, rear_off);

                var old_lx = old_rx + get_distx(mark_angle_old - 90, track);
                var old_ly = old_ry + get_disty(mark_angle_old - 90, track);
                var new_lx = new_rx + get_distx(mark_angle_new - 90, track);
                var new_ly = new_ry + get_disty(mark_angle_new - 90, track);

                var old_rx2 = old_rx + get_distx(mark_angle_old + 90, track);
                var old_ry2 = old_ry + get_disty(mark_angle_old + 90, track);
                var new_rx2 = new_rx + get_distx(mark_angle_new + 90, track);
                var new_ry2 = new_ry + get_disty(mark_angle_new + 90, track);

                drift_mark(old_lx, old_ly, new_lx, new_ly);
                drift_mark(old_rx2, old_ry2, new_rx2, new_ry2);
       
            }

            // Boost pad.
            var pad = collision(type boost_pad, x, y);
            if (pad)
            {
                velx += fx * 720 * dt;
                vely += fy * 720 * dt;
                if (trail_cd <= 0)
                {
                    trail_cd = 0.08;
                    fx_burst(x, y, 4, 120, 220, 255);
                }
            }

            if (mouse_down(0) && fire_cd <= 0)
            {
                fire_cd = 0.08;
                var muzzle_len = 20;
                var muzzle_x = x + get_distx(aim, muzzle_len);
                var muzzle_y = y + get_disty(aim, muzzle_len);
                player_bullet(muzzle_x, muzzle_y, aim);
                fx_burst(muzzle_x, muzzle_y, 3, 255, 230, 170);
            }

            if (state > 0 && hurt_cd <= 0)
            {
                state = 0;
                hurt_cd = 0.6;
                HP -= 1;
                fx_burst(x, y, 14, 255, 120, 120);
                start_camera_shake(-3, -3, 24, 16);
                if (HP <= 0)
                {
                    HP = 0;
                    GAME_OVER = true;
                }
            }
            else
            {
                state = 0;
            }
        }

        speed = sqrt(velx * velx + vely * vely);

        // Carro player.
        var body_r = 98;
        var body_g = 176;
        var body_b = 255;
        if (hurt_cd > 0)
        {
            body_r = 255;
            body_g = 130;
            body_b = 130;
        }

        var draw_angle = -angle;
        set_color(body_r, body_g, body_b);
        draw_rotated_rectangle(x , y , 36, 22, draw_angle, true);
        set_color(30, 38, 56);
        draw_rotated_rectangle(x , y , 36, 22, draw_angle, false);

        // Debug: pontos onde as marcas de drift devem aparecer (rodas traseiras).
        var rear_off_dbg = 14;
        var track_dbg = 8;
        var draw_angle_dbg = -draw_angle ;
        var rear_x_dbg = x + get_distx(draw_angle_dbg + 180, rear_off_dbg);
        var rear_y_dbg = y + get_disty(draw_angle_dbg + 180, rear_off_dbg);
        var skid_lx_dbg = rear_x_dbg + get_distx(draw_angle_dbg - 90, track_dbg);
        var skid_ly_dbg = rear_y_dbg + get_disty(draw_angle_dbg - 90, track_dbg);
        var skid_rx_dbg = rear_x_dbg + get_distx(draw_angle_dbg + 90, track_dbg);
        var skid_ry_dbg = rear_y_dbg + get_disty(draw_angle_dbg + 90, track_dbg);

        set_color(24, 28, 38);
        draw_circle(skid_lx_dbg, skid_ly_dbg, 3, true);
        draw_circle(skid_rx_dbg, skid_ry_dbg, 3, true);
        set_color(95, 110, 145);
        draw_circle(skid_lx_dbg, skid_ly_dbg, 3, false);
        draw_circle(skid_rx_dbg, skid_ry_dbg, 3, false);
        // Rodas da frente (2 retangulos).
        var wheel_angle = -draw_angle;
        var front_off = 14;
        var front_track = 9;
        var front_cx = x + get_distx(wheel_angle, front_off);
        var front_cy = y + get_disty(wheel_angle, front_off);
        var wheel_lx = front_cx + get_distx(wheel_angle - 90, front_track);
        var wheel_ly = front_cy + get_disty(wheel_angle - 90, front_track);
        var wheel_rx = front_cx + get_distx(wheel_angle + 90, front_track);
        var wheel_ry = front_cy + get_disty(wheel_angle + 90, front_track);

        set_color(24, 28, 38);
        draw_rotated_rectangle(wheel_lx, wheel_ly, 8, 4, draw_angle, true);
        draw_rotated_rectangle(wheel_rx, wheel_ry, 8, 4, draw_angle, true);
        set_color(95, 110, 145);
        draw_rotated_rectangle(wheel_lx, wheel_ly, 8, 4, draw_angle, false);
        draw_rotated_rectangle(wheel_rx, wheel_ry, 8, 4, draw_angle, false);


        // canhao no centro do carro, apontado para o rato.
        var barrel_len = 20;
        var bx = x + get_distx(aim, barrel_len);
        var by = y + get_disty(aim, barrel_len);
        set_color(80, 90, 120);
        draw_line_ex(x, y, bx, by, 5);
        set_color(130, 140, 170);
        draw_line_ex(x, y, bx, by, 2);
        set_color(55, 62, 82);
        draw_circle(x, y, 5, true);

        // Crosshair
        set_color(255, 230, 160);
        draw_circle(mx, my, 8, false);
        draw_line(mx - 12, my, mx - 4, my);
        draw_line(mx + 4, my, mx + 12, my);
        draw_line(mx, my - 12, mx, my - 4);
        draw_line(mx, my + 4, mx, my + 12);

        frame;
    }
}

process enemy_spawner()
{
    var timer = 0.0;
    var interval = 1.15;
    var max_alive = 3;

    var idx = 0;
    var sx = [220, 3000, 220, 3000, 420, 2800, 940, 2600, 580, 2420, 1650, 300, 1700, 2900];
    var sy = [220, 220, 2200, 2200, 980, 980, 1560, 1580, 420, 2040, 320, 1320, 2080, 1320];

    loop
    {
        var dt = delta();
        if (GAME_OVER)
        {
            frame;
            continue;
        }

        timer += dt;
        if (timer >= interval && ENEMIES_ALIVE < max_alive)
        {
            timer = 0;
            var ex = sx[idx % len(sx)];
            var ey = sy[idx % len(sy)];
            idx += 1;
            ENEMIES_ALIVE += 1;
            enemy_car(ex, ey);

            if (interval > 0.45) interval -= 0.01;
        }

        frame;
    }
}

process gamer_gui()
{
    loop
    {
        var p = nil;
        if (PLAYER_ID != -1) p = proc(PLAYER_ID);

        var spd = 0;
        if (p) spd = int(p.speed);

        set_draw_screen(true);

        set_alpha(184);
        set_color(10, 14, 22);
        draw_rectangle(12, 10, 430, 130, true);
        set_alpha(255);
        set_color(82, 108, 162);
        draw_rectangle(12, 10, 430, 130, false);

        set_color(245, 248, 255);
        draw_text("TOPDOWN CHAOS CARS", 22, 18, 26);
        draw_text(format("Score: {}", SCORE), 22, 50, 18);
        draw_text(format("Kills: {}", KILLS), 22, 70, 18);
        draw_text(format("Speed: {}", spd), 22, 90, 18);
        draw_text(format("Enemies: {}", ENEMIES_ALIVE), 180, 70, 18);
        draw_text("WASD drive | SHIFT boost | SPACE drift | Mouse shoot", 22, 112, 16);

        var hp_ratio = HP / HP_MAX;
        set_color(26, 26, 34);
        draw_rectangle(180, 50, 180, 12, true);
        set_color(255, 100, 120);
        draw_rectangle(180, 50, 180 * hp_ratio, 12, true);
        set_color(255, 185, 195);
        draw_rectangle(180, 50, 180, 12, false);

        if (GAME_OVER)
        {
            set_color(255, 120, 120);
            draw_text("WRECKED! Press R", VIEW_W / 2 - 140, VIEW_H / 2 - 14, 34);
        }

        set_draw_screen(false);
        frame;
    }
}

def build_world()
{
    // Borda externa.
    wall_block(WORLD_W / 2, 16, WORLD_W, 32, 90, 102, 128);
    wall_block(WORLD_W / 2, WORLD_H - 16, WORLD_W, 32, 90, 102, 128);
    wall_block(16, WORLD_H / 2, 32, WORLD_H, 90, 102, 128);
    wall_block(WORLD_W - 16, WORLD_H / 2, 32, WORLD_H, 90, 102, 128);

    // Blocos internos (quadras).
    wall_block(540, 420, 520, 42, 102, 120, 150);
    wall_block(540, 860, 520, 42, 102, 120, 150);
    wall_block(280, 640, 42, 480, 102, 120, 150);
    wall_block(800, 640, 42, 480, 102, 120, 150);

    wall_block(1410, 360, 620, 42, 102, 120, 150);
    wall_block(1410, 920, 620, 42, 102, 120, 150);
    wall_block(1090, 640, 42, 600, 102, 120, 150);
    wall_block(1730, 640, 42, 600, 102, 120, 150);

    wall_block(2460, 440, 520, 42, 102, 120, 150);
    wall_block(2460, 880, 520, 42, 102, 120, 150);
    wall_block(2200, 660, 42, 480, 102, 120, 150);
    wall_block(2720, 660, 42, 480, 102, 120, 150);

    wall_block(830, 1540, 760, 42, 102, 120, 150);
    wall_block(830, 1980, 760, 42, 102, 120, 150);
    wall_block(450, 1760, 42, 480, 102, 120, 150);
    wall_block(1210, 1760, 42, 480, 102, 120, 150);

    wall_block(2250, 1500, 760, 42, 102, 120, 150);
    wall_block(2250, 2020, 760, 42, 102, 120, 150);
    wall_block(1870, 1760, 42, 560, 102, 120, 150);
    wall_block(2630, 1760, 42, 560, 102, 120, 150);

    // Boost pads.
    boost_pad(540, 640);
    boost_pad(1410, 640);
    boost_pad(2460, 640);
    boost_pad(830, 1760);
    boost_pad(2250, 1760);
}

def start_game()
{
    let_me_alone();
    GAME_OVER = false;
    SCORE = 0;
    KILLS = 0;
    HP = HP_MAX;
    ENEMIES_ALIVE = 0;
    PLAYER_ID = -1;
    CAM_X = 0;
    CAM_Y = 0;

    build_world();
    enemy_spawner();

    var p = player_car(180, 180);
    if (p) PLAYER_ID = p.id;
    gamer_gui();
}

set_window_size(VIEW_W, VIEW_H);
set_window_title("Topdown Chaos Cars");
set_design_resolution(VIEW_W, VIEW_H);
set_virtual_screen_enabled(true);
set_screen_scale_mode(0);
init_collision(0, 0, WORLD_W, WORLD_H);

start_game();

loop
{
    var dt = delta();
    var p = nil;
    if (PLAYER_ID != -1) p = proc(PLAYER_ID);

    if (p)
    {
        var tx = p.x - VIEW_W * 0.5;
        var ty = p.y - VIEW_H * 0.5;
        tx = clamp(tx, 0, WORLD_W - VIEW_W);
        ty = clamp(ty, 0, WORLD_H - VIEW_H);
        CAM_X += (tx - CAM_X) * math.min(1.0, dt * 7.5);
        CAM_Y += (ty - CAM_Y) * math.min(1.0, dt * 7.5);
    }

    set_scroll(CAM_X, CAM_Y);
    draw_backdrop(CAM_X, CAM_Y);

    if (key_pressed(KEY_R))
    {
        start_game();
    }

    if (key_pressed(KEY_ESCAPE))
    {
        let_me_alone();
        break;
    }

    frame;
}
