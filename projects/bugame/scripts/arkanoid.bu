// === ARKANOID - PHYSICS FOCUSED ===

import math;

var WINDOW_WIDTH = 800;
var WINDOW_HEIGHT = 600;

var BALL_RADIUS = 8;
var BALL_BASE_SPEED = 350;
var BALL_MAX_SPEED = 650;
var BALL_MIN_SPEED = 200;

var PADDLE_WIDTH = 100;
var PADDLE_HEIGHT = 16;
var PADDLE_SPEED = 450;

var BRICK_WIDTH = 60;
var BRICK_HEIGHT = 24;
var BRICK_COLS = 12;
var BRICK_ROWS = 6;

var SCORE = 0;
var LIVES = 3;

var KEY_W = 87;
var KEY_A = 65;
var KEY_S = 83;
var KEY_D = 68;
var KEY_ESCAPE = 256;
var KEY_LEFT = 263;
var KEY_RIGHT = 262;
var KEY_R = 82;
 


// ============================================
// EFFECTS
// ============================================
def create_wall_impact(wx, wy, vx, vy)
{
    // Partículas na direção oposta
    var angle = atan2(-vy, -vx);
    
    for (var i = 0; i < 5; i += 1)
    {
        var spread = angle + math.rand(-0.5, 0.5);
        particle_spark(wx, wy, spread);
    }
}

def create_paddle_impact(px, py, offset)
{
    // Mais partículas nas bordas
    var count = 3 + int(abs(offset) * 4);
    
    for (var i = 0; i < count; i += 1)
    {
        var angle = -90 + math.rand(-60, 60);
        particle_spark(px, py, angle);
    }
}

def create_brick_hit(bx, by)
{
    // Explosão de partículas
    for (var i = 0; i < 12; i += 1)
    {
        var angle = math.rand(0, 360);
        particle_chunk(bx, by, angle);
    }
}

// ============================================
// LEVEL SETUP
// ============================================
def create_bricks()
{
    var start_x = (WINDOW_WIDTH - BRICK_COLS * BRICK_WIDTH) / 2 + BRICK_WIDTH/2;
    var start_y = 80;
    
    for (var row = 0; row < BRICK_ROWS; row += 1)
    {
        for (var col = 0; col < BRICK_COLS; col += 1)
        {
            var bx = start_x + col * BRICK_WIDTH;
            var by = start_y + row * (BRICK_HEIGHT + 4);
            brick(bx, by, row);
        }
    }
}


// ============================================
// PADDLE
// ============================================
process paddle()
{
    x = WINDOW_WIDTH / 2;
    y = WINDOW_HEIGHT - 60;
    var w = PADDLE_WIDTH;
    var h = PADDLE_HEIGHT;
    
    set_rect_shape(0,0, w, h);
    
    loop
    {
        var dt = delta();
        var prev_x = x;
        var prev_y = y;
        
        // Input
        if (key_down(KEY_LEFT) || key_down(KEY_A))
        {
            x -= PADDLE_SPEED * dt;
        }
        if (key_down(KEY_RIGHT) || key_down(KEY_D))
        {
            x += PADDLE_SPEED * dt;
        }
        
        // Screen bounds
        x = math.clamp(x, w/2, WINDOW_WIDTH - w/2);
        xold = prev_x;
        yold = prev_y;
        
        // Draw paddle com gradiente
        set_alpha(255);
        set_color(60, 60, 80);
        draw_rectangle(x - w/2, y - h/2, w, h, true);
        
        set_color(100, 150, 220);
        draw_rectangle(x - w/2 + 2, y - h/2 + 2, w - 4, h - 8, true);
        
        frame;
    }
}


// ============================================
// BALL - PHYSICS AVANÇADA
// ============================================
process ball(start_x, start_y, start_angle)
{
    x = start_x;
    y = start_y;
    var radius = BALL_RADIUS;
    
    // Velocidade em componentes
    speed = BALL_BASE_SPEED;
    velx = get_distx(start_angle, speed);
    vely = get_disty(start_angle, speed);
    
    // Trail effect
    var trail_x = [x, x, x, x, x];
    var trail_y = [y, y, y, y, y];
    var trail_idx = 0;
    var brick_hit_cooldown = 0.0;
    
    set_circle_shape(radius);
    
    loop
    {
        var dt = delta();
        var prev_x = x;
        var prev_y = y;
        if (brick_hit_cooldown > 0)
        {
            brick_hit_cooldown -= dt;
        }
        
        // Update trail
        trail_x[trail_idx] = x;
        trail_y[trail_idx] = y;
        trail_idx = (trail_idx + 1) % 5;
        
        // Move ball
        x += velx * dt;
        y += vely * dt;
        
        // Calculate current speed
        speed = sqrt(velx * velx + vely * vely);
        
        // ==========================================
        // WALL COLLISIONS
        // ==========================================
        
        // Left/Right walls
        if (x - radius < 0)
        {
            x = radius;
            velx = abs(velx);
            create_wall_impact(x, y, velx, vely);
        }
        elif (x + radius > WINDOW_WIDTH)
        {
            x = WINDOW_WIDTH - radius;
            velx = -abs(velx);
            create_wall_impact(x, y, velx, vely );
        }
        
        // Top wall
        if (y - radius < 0)
        {
            y = radius;
            vely = abs(vely);
            create_wall_impact(x, y, velx, vely);
        }
        
        // Death zone (bottom)
        if (y > WINDOW_HEIGHT + 20)
        {
            LIVES -= 1;
            if (LIVES > 0)
            {
                // Respawn
                ball(WINDOW_WIDTH/2, WINDOW_HEIGHT - 100, 90);
            }
            break;
        }
        
        // ==========================================
        // PADDLE COLLISION - FISICA REALISTA
        // ==========================================
       
        var paddle_hit = collision(type paddle, x, y);
        if (paddle_hit && vely > 0)
        {
            // Posição relativa no paddle (-1 a 1)
            var hit_offset = (x - paddle_hit.x) / (PADDLE_WIDTH / 2);
            hit_offset = math.clamp(hit_offset, -0.95, 0.95);
            
            // Ângulo de bounce baseado em onde acerta
            // Centro = -90° (vertical)
            // Bordas = -45° ou -135° (diagonal)
            var bounce_angle = -90 + hit_offset * 60;
            
      
            var paddle_vel = (paddle_hit.x - paddle_hit.xold) / dt;
            var english = paddle_vel * 0.3;
            
            // Calcula nova velocidade
            var new_speed = math.min(speed + 20, BALL_MAX_SPEED);
            velx = get_distx(bounce_angle, new_speed) + english;
            vely = get_disty(bounce_angle, new_speed);
            
            // Garante que vy é sempre negativo (sobe)
            vely = -abs(vely);
            
            // Empurra bola para fora do paddle
            y = paddle_hit.y - PADDLE_HEIGHT/2 - radius - 1;
            
            create_paddle_impact(x, y, hit_offset);
        }
        
        // ==========================================
        // BRICK COLLISION - SINGLE HIT STABLE
        // ==========================================
        if (brick_hit_cooldown <= 0)
        {
            var brick_hit = collision(type brick, x, y);

            // Testa também no meio do passo para reduzir tunneling
            if (!brick_hit)
            {
                var mid_x = prev_x + (x - prev_x) * 0.5;
                var mid_y = prev_y + (y - prev_y) * 0.5;
                brick_hit = collision(type brick, mid_x, mid_y);
                if (brick_hit)
                {
                    x = mid_x;
                    y = mid_y;
                }
            }

            if (brick_hit)
            {
                brick_hit.hp -= 1;
                SCORE += 10;

                var dx = x - brick_hit.x;
                var dy = y - brick_hit.y;
                var overlap_x = (BRICK_WIDTH * 0.5 + radius) - abs(dx);
                var overlap_y = (BRICK_HEIGHT * 0.5 + radius) - abs(dy);

                // Resolve no eixo de menor penetração
                if (overlap_x < overlap_y)
                {
                    velx = -velx;
                    if (dx < 0)
                    {
                        x = brick_hit.x - BRICK_WIDTH/2 - radius - 1;
                    }
                    else
                    {
                        x = brick_hit.x + BRICK_WIDTH/2 + radius + 1;
                    }
                }
                else
                {
                    vely = -vely;
                    if (dy < 0)
                    {
                        y = brick_hit.y - BRICK_HEIGHT/2 - radius - 1;
                    }
                    else
                    {
                        y = brick_hit.y + BRICK_HEIGHT/2 + radius + 1;
                    }
                }

                // Cooldown curto para não registrar múltiplos hits colados
                brick_hit_cooldown = 0.03;

                // Previne velocidade muito baixa
                speed = sqrt(velx * velx + vely * vely);
                if (speed < BALL_MIN_SPEED)
                {
                    var angle = atan2(vely, velx);
                    velx = get_distx(angle, BALL_MIN_SPEED);
                    vely = get_disty(angle, BALL_MIN_SPEED);
                }

                create_brick_hit(brick_hit.x, brick_hit.y);
            }
        }
        
        // ==========================================
        // DRAW BALL COM TRAIL
        // ==========================================
        
        // Trail
        for (var t = 0; t < 5; t += 1)
        {
            var alpha = 50 - t * 10;
            var size = radius - t * 1;
            set_color(255, 255, 150);
            set_alpha(alpha);
            draw_circle(trail_x[t], trail_y[t], size, true);
        }
        
        // Ball principal
        set_alpha(255);
        set_color(255, 255, 200);
        draw_circle(x, y, radius, true);
        
        // Highlight
        set_color(255, 255, 255);
        draw_circle(x - 2, y - 2, radius / 3, true);
        
        frame;
    }
}


// ============================================
// BRICK
// ============================================
process brick(bx, by, row)
{
    x = bx;
    y = by;
    hp = 1;
    
    var w = BRICK_WIDTH;
    var h = BRICK_HEIGHT;
    
    // Cores por linha
    var colors = [
        [220, 80, 80],    // Red
        [220, 150, 80],   // Orange
        [220, 220, 80],   // Yellow
        [80, 220, 120],   // Green
        [80, 150, 220],   // Blue
        [180, 80, 220]    // Purple
    ];
    
    var col = colors[row % len(colors)];
    
    set_rect_shape(0,0, w, h);
    
    var wobble = 0.0;
    var hit_flash = 0.0;
    
    loop
    {
        var dt = delta();
        
        if (hp <= 0)
        {
            break;
        }
        
        if (hit_flash > 0)
        {
            hit_flash -= dt * 8;
            wobble = sin(hit_flash * 40) * 3;
        }
        
        // Draw com outline
        set_alpha(255);
        set_color(col[0] * 0.5, col[1] * 0.5, col[2] * 0.5);
        draw_rectangle(x + wobble - w/2, y - h/2, w, h, true);
        
        var flash = int(hit_flash * 100);
        set_color(col[0] + flash, col[1] + flash, col[2] + flash);
        draw_rectangle(x + wobble - w/2 + 2, y - h/2 + 2, w - 4, h - 4, true);
        
        frame;
    }
}



process particle_spark(sx, sy, angle)
{
    x = sx;
    y = sy;
    speed = math.rand(100, 200);
    velx = get_distx(angle, speed);
    vely = get_disty(angle, speed);
    hp = 0.3;
    size = 4;
    
    loop
    {
        var dt = delta();
        hp -= dt;
        
        if (hp <= 0)
        {
            break;
        }
        
        x += velx * dt;
        y += vely * dt;
        vely += 500 * dt;  // Gravity
        
        size = 4 * (hp / 0.3);
        
        set_color(255, 255, 150);
        set_alpha(int(255 * hp / 0.3));
        draw_circle(x, y, size, true);
        
        frame;
    }
}

process particle_chunk(cx, cy, angle)
{
    x = cx;
    y = cy;
    speed = math.rand(80, 180);
    velx = get_distx(angle, speed);
    vely = get_disty(angle, speed);
    hp = 0.5;
    var rot = math.rand(0, 360);
    var rot_speed = math.rand(-400, 400);
    size = math.rand(4, 8);
    
    loop
    {
        var dt = delta();
        hp -= dt;
        
        if (hp <= 0)
        {
            break;
        }
        
        x += velx * dt;
        y += vely * dt;
        vely += 400 * dt;
        rot += rot_speed * dt;
        
        velx *= 0.98;  // Drag
        
        set_color(200, 200, 200);
        set_alpha(int(255 * hp / 0.5));
        
        // Rotating square
        var s = size * (hp / 0.5);
        var c = cos(rot);
        var sn = sin(rot);
        
        draw_line(x + c*s - sn*s, y + sn*s + c*s,
                 x - c*s - sn*s, y - sn*s + c*s);
        draw_line(x - c*s - sn*s, y - sn*s + c*s,
                 x - c*s + sn*s, y - sn*s - c*s);
        draw_line(x - c*s + sn*s, y - sn*s - c*s,
                 x + c*s + sn*s, y + sn*s - c*s);
        draw_line(x + c*s + sn*s, y + sn*s - c*s,
                 x + c*s - sn*s, y + sn*s + c*s);
        set_alpha(255);
        frame;
    }
}




// ============================================
// MAIN
// ============================================
set_window_size(WINDOW_WIDTH, WINDOW_HEIGHT);
set_window_title("Bu Arkanoid - Physics Demo");

set_design_resolution(WINDOW_WIDTH, WINDOW_HEIGHT);
set_screen_scale_mode(0); // 0=fit, 1=stretch, 2=fill, 3=letterbox
set_virtual_screen_enabled(true);

init_collision(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

create_bricks();
paddle();
ball(WINDOW_WIDTH/2, WINDOW_HEIGHT - 100, -90);

loop
{
    var dt = delta();
    
    set_alpha(255); 
    
    // UI
    set_color(200, 200, 200);
    draw_text(format("Score: {}", SCORE), 20, 20, 18);
    draw_text(format("Lives: {}", LIVES), WINDOW_WIDTH - 100, 20, 18);
    
    // Check win
    var bricks_left = count_processes(type brick);
    if (bricks_left == 0)
    {
        set_color(255, 255, 100);
        draw_text("YOU WIN! Press R to restart", 200, 300, 24);
        
        if (key_pressed(KEY_R))
        {
            let_me_alone();
            create_bricks();
            paddle();
            ball(WINDOW_WIDTH/2, WINDOW_HEIGHT - 100, 90);
            SCORE = 0;
            LIVES = 3;
        }
    }
    
    // Game Over
    if (LIVES <= 0)
    {
        set_color(255, 100, 100);
        draw_text("GAME OVER! Press R to restart", 180, 300, 24);
        
        if (key_pressed(KEY_R))
        {
            let_me_alone();
            create_bricks();
            paddle();
            ball(WINDOW_WIDTH/2, WINDOW_HEIGHT - 100, 90);
            SCORE = 0;
            LIVES = 3;
        }
    }
    
    if (key_down(KEY_ESCAPE))
    {
        let_me_alone();
        break;
    }
    
    frame;
}
