// === TOPDOWN CHAOS CARS ===

import math;
import os;

var VIEW_W = 1280;
var VIEW_H = 720;
var WORLD_W = 3200;
var WORLD_H = 2400;

var KEY_W = 87;
var KEY_A = 65;
var KEY_S = 83;
var KEY_D = 68;
var KEY_UP = 265;
var KEY_LEFT = 263;
var KEY_DOWN = 264;
var KEY_RIGHT = 262;
var KEY_SPACE = 32;
var KEY_SHIFT = 340;
var KEY_R = 82;
var KEY_ESCAPE = 256;
var KEY_F = 70;
var KEY_F1 = 290;
var KEY_F2 = 291;

var KEY_FIRE = KEY_F;

var PLATFORM_NAME = os.platform;
var ENV_ANDROID_ROOT = os.getenv("ANDROID_ROOT");
var ENV_ANDROID_DATA = os.getenv("ANDROID_DATA");
var IS_ANDROID_ENV = (ENV_ANDROID_ROOT != nil || ENV_ANDROID_DATA != nil);
var IS_TOUCH_PLATFORM = (PLATFORM_NAME == "android" || PLATFORM_NAME == "emscripten" || IS_ANDROID_ENV);
var TOUCH_UI_ENABLED = IS_TOUCH_PLATFORM;
var TOUCH_UI_VISIBLE = IS_TOUCH_PLATFORM;
var TOUCH_RUNTIME_AUTO = false;
var HUD_HELP_VISIBLE = false;

var PLAYER_ID = -1;
var CAM_X = 0.0;
var CAM_Y = 0.0;
var GAME_OVER = false;
var SCORE = 0;
var KILLS = 0;
var HP_MAX = 10;
var HP = 10;
var ENEMIES_ALIVE = 0;
var SHOW_WAYPOINTS = true;
var CAR_HIT_RADIUS = 30;
var CAR_BOUNCE_IMPULSE = 120;
var ENEMY_BULLET_DAMAGE = 1;

var PICKUP_HEAL = 0;
var PICKUP_RAPID = 1;
var PICKUP_SHIELD = 2;
var PICKUP_OVERDRIVE = 3;

var PLAYER_RAPID_TIMER = 0.0;
var PLAYER_SHIELD_TIMER = 0.0;
var PLAYER_OVERDRIVE_TIMER = 0.0;

var JOY_BASE_X = 150.0;
var JOY_BASE_Y = 560.0;
var JOY_RADIUS = 72.0;
var JOY_CAPTURE_RADIUS = 104.0;
var JOY_KNOB_RADIUS = 34.0;
var JOY_DEADZONE = 0.14;
var JOY_ACTIVE = false;
var JOY_TOUCH_ID = -1;
var JOY_KNOB_X = 150.0;
var JOY_KNOB_Y = 560.0;
var JOY_AXIS_X = 0.0;
var JOY_AXIS_Y = 0.0;
var BTN_BOOST_X = 0.0;
var BTN_BOOST_Y = 0.0;
var BTN_BOOST_W = 0.0;
var BTN_BOOST_H = 0.0;
var BTN_DRIFT_X = 0.0;
var BTN_DRIFT_Y = 0.0;
var BTN_DRIFT_W = 0.0;
var BTN_DRIFT_H = 0.0;
var BTN_ACCEL_X = 0.0;
var BTN_ACCEL_Y = 0.0;
var BTN_ACCEL_W = 0.0;
var BTN_ACCEL_H = 0.0;
var BTN_BRAKE_X = 0.0;
var BTN_BRAKE_Y = 0.0;
var BTN_BRAKE_W = 0.0;
var BTN_BRAKE_H = 0.0;
var BTN_FIRE_X = 0.0;
var BTN_FIRE_Y = 0.0;
var BTN_FIRE_W = 0.0;
var BTN_FIRE_H = 0.0;
var BTN_RST_X = 0.0;
var BTN_RST_Y = 0.0;
var BTN_RST_W = 0.0;
var BTN_RST_H = 0.0;
var BTN_ESC_X = 0.0;
var BTN_ESC_Y = 0.0;
var BTN_ESC_W = 0.0;
var BTN_ESC_H = 0.0;

def joystick_reset_state()
{
    JOY_ACTIVE = false;
    JOY_TOUCH_ID = -1;
    JOY_AXIS_X = 0;
    JOY_AXIS_Y = 0;
    JOY_KNOB_X = JOY_BASE_X;
    JOY_KNOB_Y = JOY_BASE_Y;
}

def joystick_apply_touch(sx, sy)
{
    var dx = sx - JOY_BASE_X;
    var dy = sy - JOY_BASE_Y;
    var dist = sqrt(dx * dx + dy * dy);
    if (dist > JOY_RADIUS)
    {
        var k = JOY_RADIUS / dist;
        dx *= k;
        dy *= k;
    }

    JOY_KNOB_X = JOY_BASE_X + dx;
    JOY_KNOB_Y = JOY_BASE_Y + dy;
    JOY_AXIS_X = dx / JOY_RADIUS;
    JOY_AXIS_Y = dy / JOY_RADIUS;

    if (abs(JOY_AXIS_X) < JOY_DEADZONE) JOY_AXIS_X = 0;
    if (abs(JOY_AXIS_Y) < JOY_DEADZONE) JOY_AXIS_Y = 0;
}

def joystick_update()
{
    if (!TOUCH_UI_ENABLED || touch_count() <= 0)
    {
        joystick_reset_state();
        return;
    }

    var count = touch_count();
    if (JOY_ACTIVE)
    {
        var i = 0;
        while (i < count)
        {
            if (get_touch_id(i) == JOY_TOUCH_ID)
            {
                joystick_apply_touch(get_touch_screen_x(i), get_touch_screen_y(i));
                return;
            }
            i += 1;
        }
        joystick_reset_state();
    }

    var i = 0;
    while (i < count)
    {
        var sx = get_touch_screen_x(i);
        var sy = get_touch_screen_y(i);
        var dx = sx - JOY_BASE_X;
        var dy = sy - JOY_BASE_Y;
        var dist = sqrt(dx * dx + dy * dy);

        if (sx < VIEW_W * 0.52 && dist <= JOY_CAPTURE_RADIUS)
        {
            JOY_ACTIVE = true;
            JOY_TOUCH_ID = get_touch_id(i);
            joystick_apply_touch(sx, sy);
            return;
        }
        i += 1;
    }

    joystick_reset_state();
}

def draw_joystick()
{
    if (!TOUCH_UI_ENABLED || !TOUCH_UI_VISIBLE) return;

    set_alpha(55);
    set_color(26, 36, 62);
    draw_circle(JOY_BASE_X, JOY_BASE_Y, JOY_CAPTURE_RADIUS, true);
    set_alpha(170);
    set_color(146, 188, 255);
    draw_circle(JOY_BASE_X, JOY_BASE_Y, JOY_RADIUS, false);

    set_alpha(95);
    set_color(180, 215, 255);
    draw_circle(JOY_BASE_X, JOY_BASE_Y, 12, true);

    if (JOY_ACTIVE) set_color(255, 186, 90);
    else set_color(180, 214, 255);
    set_alpha(170);
    draw_circle(JOY_KNOB_X, JOY_KNOB_Y, JOY_KNOB_RADIUS, true);
    set_alpha(235);
    set_color(245, 248, 255);
    draw_circle(JOY_KNOB_X, JOY_KNOB_Y, JOY_KNOB_RADIUS, false);

    set_alpha(255);
}

def point_in_rect(px, py, rx, ry, rw, rh)
{
    if (px < rx) return false;
    if (py < ry) return false;
    if (px > rx + rw) return false;
    if (py > ry + rh) return false;
    return true;
}

def is_touch_on_control(sx, sy)
{
    var dx = sx - JOY_BASE_X;
    var dy = sy - JOY_BASE_Y;
    if (dx * dx + dy * dy <= JOY_CAPTURE_RADIUS * JOY_CAPTURE_RADIUS) return true;

    if (point_in_rect(sx, sy, BTN_BOOST_X, BTN_BOOST_Y, BTN_BOOST_W, BTN_BOOST_H)) return true;
    if (point_in_rect(sx, sy, BTN_DRIFT_X, BTN_DRIFT_Y, BTN_DRIFT_W, BTN_DRIFT_H)) return true;
    if (point_in_rect(sx, sy, BTN_ACCEL_X, BTN_ACCEL_Y, BTN_ACCEL_W, BTN_ACCEL_H)) return true;
    if (point_in_rect(sx, sy, BTN_BRAKE_X, BTN_BRAKE_Y, BTN_BRAKE_W, BTN_BRAKE_H)) return true;
    if (point_in_rect(sx, sy, BTN_FIRE_X, BTN_FIRE_Y, BTN_FIRE_W, BTN_FIRE_H)) return true;
    if (point_in_rect(sx, sy, BTN_RST_X, BTN_RST_Y, BTN_RST_W, BTN_RST_H)) return true;
    if (point_in_rect(sx, sy, BTN_ESC_X, BTN_ESC_Y, BTN_ESC_W, BTN_ESC_H)) return true;

    return false;
}

def setup_touch_controls()
{
    vkey_clear();

    if (!TOUCH_UI_ENABLED)
    {
        vkey_set_visible(false);
        TOUCH_UI_VISIBLE = false;
        joystick_reset_state();
        return;
    }

    var margin = 26;
    JOY_BASE_X = margin + JOY_CAPTURE_RADIUS;
    JOY_BASE_Y = VIEW_H - margin - JOY_CAPTURE_RADIUS;
    joystick_reset_state();

    // Mini dpad de condução (lado esquerdo, ao lado do joystick): boost/drift
    var dpad = 92;
    BTN_BOOST_W = dpad;
    BTN_BOOST_H = dpad;
    BTN_DRIFT_W = dpad;
    BTN_DRIFT_H = dpad;
    BTN_BOOST_X = JOY_BASE_X + JOY_CAPTURE_RADIUS + 16;
    BTN_BOOST_Y = JOY_BASE_Y - dpad - 10;
    BTN_DRIFT_X = JOY_BASE_X + JOY_CAPTURE_RADIUS + 16;
    BTN_DRIFT_Y = JOY_BASE_Y + 10;

    vkey_add(KEY_SHIFT, BTN_BOOST_X, BTN_BOOST_Y, BTN_BOOST_W, BTN_BOOST_H); // boost
    vkey_add(KEY_SPACE, BTN_DRIFT_X, BTN_DRIFT_Y, BTN_DRIFT_W, BTN_DRIFT_H); // drift

    // Coluna direita: acelerar, recuar, disparar.
    var control_size = 112;
    var control_gap = 12;
    BTN_FIRE_W = control_size;
    BTN_FIRE_H = control_size;
    BTN_FIRE_X = VIEW_W - margin - control_size;
    BTN_FIRE_Y = VIEW_H - margin - control_size;

    BTN_BRAKE_W = control_size;
    BTN_BRAKE_H = control_size;
    BTN_BRAKE_X = BTN_FIRE_X;
    BTN_BRAKE_Y = BTN_FIRE_Y - control_gap - control_size;

    BTN_ACCEL_W = control_size;
    BTN_ACCEL_H = control_size;
    BTN_ACCEL_X = BTN_FIRE_X;
    BTN_ACCEL_Y = BTN_BRAKE_Y - control_gap - control_size;

    vkey_add(KEY_UP, BTN_ACCEL_X, BTN_ACCEL_Y, BTN_ACCEL_W, BTN_ACCEL_H);       // accel
    vkey_add(KEY_DOWN, BTN_BRAKE_X, BTN_BRAKE_Y, BTN_BRAKE_W, BTN_BRAKE_H);     // reverse
    vkey_add(KEY_FIRE, BTN_FIRE_X, BTN_FIRE_Y, BTN_FIRE_W, BTN_FIRE_H);

    // Utilitarios no topo direito
    BTN_RST_X = VIEW_W - 180;
    BTN_RST_Y = 20;
    BTN_RST_W = 70;
    BTN_RST_H = 46;
    BTN_ESC_X = VIEW_W - 96;
    BTN_ESC_Y = 20;
    BTN_ESC_W = 70;
    BTN_ESC_H = 46;

    vkey_add(KEY_R, BTN_RST_X, BTN_RST_Y, BTN_RST_W, BTN_RST_H);      // restart
    vkey_add(KEY_ESCAPE, BTN_ESC_X, BTN_ESC_Y, BTN_ESC_W, BTN_ESC_H); // exit

    vkey_set_visible(TOUCH_UI_VISIBLE);
}

// Fallback: se plataforma for detetada como desktop por engano,
// ativa touch UI assim que o primeiro toque real aparecer.
def ensure_touch_ui_runtime()
{
    if (TOUCH_UI_ENABLED) return;
    if (touch_count() <= 0) return;

    TOUCH_UI_ENABLED = true;
    TOUCH_UI_VISIBLE = true;
    TOUCH_RUNTIME_AUTO = true;
    setup_touch_controls();
}

// Escolhe um toque livre do ecrã para apontar o canhão (fora dos controlos).
// Retorna [screen_x, screen_y, ok]
def get_aim_touch_screen()
{
    var count = touch_count();
    var i = count - 1;
    while (i >= 0)
    {
        var sx = get_touch_screen_x(i);
        var sy = get_touch_screen_y(i);
        if (!is_touch_on_control(sx, sy))
        {
            return [sx, sy, 1];
        }
        i -= 1;
    }
    return [0, 0, 0];
}

// ============================================
// WAYPOINT GRAPH - estradas do mapa
// ============================================
// 20 waypoints nas interseccoes das estradas.
//
//  Row 0: y=180  (top road)        → WP 0,1,2,3
//  Row 1: y=1050 (middle road)     → WP 4,5,6,7,8
//  Row 2: y=1400 (above D/E)       → WP 9,10,11
//  Row 3: y=1750 (D/E sides)       → WP 12,13,14
//  Row 4: y=2200 (bottom road)     → WP 15,16,17,18,19

var NAV_COUNT = 20;
var NAV_X = [
    180, 950, 1950, 3020,
    180, 950, 1540, 1950, 3020,
    180, 1540, 3020,
    180, 1540, 3020,
    180, 830, 1540, 2250, 3020
];
var NAV_Y = [
    180, 180, 180, 180,
    1050, 1050, 1050, 1050, 1050,
    1400, 1400, 1400,
    1750, 1750, 1750,
    2200, 2200, 2200, 2200, 2200
];

// Adjacencia: flat array, MAX_ADJ vizinhos por WP (-1 = vazio).
var MAX_ADJ = 4;
var NAV_ADJ = [
//  WP0           WP1           WP2           WP3
    1,  4, -1,-1, 0,  2,  5,-1, 1,  3,  7,-1, 2,  8, -1,-1,
//  WP4           WP5           WP6           WP7           WP8
    0,  5,  9,-1, 1,  4,  6,-1, 5,  7, 10,-1, 2,  6,  8,-1, 3,  7, 11,-1,
//  WP9           WP10          WP11
    4, 10, 12,-1, 6,  9, 11,13, 8, 10, 14,-1,
//  WP12          WP13          WP14
    9, 15, -1,-1, 10,17, -1,-1, 11,19, -1,-1,
//  WP15          WP16          WP17          WP18          WP19
   12, 16, -1,-1, 15,17, -1,-1, 13,16, 18,-1, 17,19, -1,-1, 14,18, -1,-1
];

var NAV_ADJ_COUNT = [
    2, 3, 3, 2,
    3, 3, 3, 3, 3,
    3, 4, 3,
    2, 2, 2,
    2, 2, 3, 2, 2
];

// Tabela Floyd-Warshall: NEXT_HOP[from * NAV_COUNT + to] = proximo WP.
var NAV_DIST = [];
var NEXT_HOP = [];



// Tenta encontrar um ponto livre perto da posicao atual para sair de cantos/parede.
// Retorna [x, y, ok] onde ok=1 se encontrou.
def find_free_spot(_x, _y, _max_r)
{
    if (place_free(_x, _y))
    {
        return [_x, _y, 1];
    }

    var r = 2;
    while (r <= _max_r)
    {
        var a = 0;
        while (a < 360)
        {
            var tx = _x + get_distx(a, r);
            var ty = _y + get_disty(a, r);
            if (place_free(tx, ty))
            {
                return [tx, ty, 1];
            }
            a += 20;
        }
        r += 2;
    }

    return [_x, _y, 0];
}

// Verifica se ha caminho livre entre dois pontos (raio de colisao).
// Testa place_free a cada 16 pixels ao longo da linha.
def line_free(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;
    var dist = sqrt(dx * dx + dy * dy);
    var steps = int(dist / 16);
    if (steps < 2) steps = 2;
    var i = 1;
    while (i < steps)
    {
        var t = i / steps;
        if (!place_free(x1 + dx * t, y1 + dy * t))
            return false;
        i += 1;
    }
    return true;
}

// Pre-computa tabela de caminhos mais curtos (Floyd-Warshall).
// Chamado uma vez no startup. O(n^3) com n=20 = 8000 iteracoes.
def nav_precompute()
{
    var INF = 999999;
    var total = NAV_COUNT * NAV_COUNT;

    // Inicializar arrays
    var i = 0;
    while (i < total)
    {
        NAV_DIST.push(INF);
        NEXT_HOP.push(-1);
        i += 1;
    }

    // Distancia a si proprio = 0
    i = 0;
    while (i < NAV_COUNT)
    {
        NAV_DIST[i * NAV_COUNT + i] = 0;
        NEXT_HOP[i * NAV_COUNT + i] = i;
        i += 1;
    }

    // Distancias das arestas
    i = 0;
    while (i < NAV_COUNT)
    {
        var n = 0;
        while (n < NAV_ADJ_COUNT[i])
        {
            var j = NAV_ADJ[i * MAX_ADJ + n];
            var dx = NAV_X[i] - NAV_X[j];
            var dy = NAV_Y[i] - NAV_Y[j];
            var d = sqrt(dx * dx + dy * dy);
            NAV_DIST[i * NAV_COUNT + j] = d;
            NEXT_HOP[i * NAV_COUNT + j] = j;
            n += 1;
        }
        i += 1;
    }

    // Floyd-Warshall
    var k = 0;
    while (k < NAV_COUNT)
    {
        i = 0;
        while (i < NAV_COUNT)
        {
            var j = 0;
            while (j < NAV_COUNT)
            {
                var through_k = NAV_DIST[i * NAV_COUNT + k] + NAV_DIST[k * NAV_COUNT + j];
                if (through_k < NAV_DIST[i * NAV_COUNT + j])
                {
                    NAV_DIST[i * NAV_COUNT + j] = through_k;
                    NEXT_HOP[i * NAV_COUNT + j] = NEXT_HOP[i * NAV_COUNT + k];
                }
                j += 1;
            }
            i += 1;
        }
        k += 1;
    }
}

// Encontra o waypoint mais perto de (px, py).
def nav_find_nearest(px, py)
{
    var best = 0;
    var best_d = 99999999;
    var i = 0;
    while (i < NAV_COUNT)
    {
        var d = get_dist(px, py, NAV_X[i], NAV_Y[i]);
        if (d < best_d)
        {
            best_d = d;
            best = i;
        }
        i += 1;
    }
    return best;
}

// Retorna o proximo waypoint no caminho mais curto de 'from' para 'to'.
// O(1) - lookup na tabela pre-computada.
def nav_next(from_wp, to_wp)
{
    return NEXT_HOP[from_wp * NAV_COUNT + to_wp];
}

def draw_waypoints_overlay()
{
    if (!SHOW_WAYPOINTS) return;

    // Desenha arestas do grafo.
    var i = 0;
    while (i < NAV_COUNT)
    {
        var n = 0;
        while (n < NAV_ADJ_COUNT[i])
        {
            var j = NAV_ADJ[i * MAX_ADJ + n];
            if (j > i)
            {
                set_alpha(80);
                set_color(95, 210, 255);
                draw_line(NAV_X[i], NAV_Y[i], NAV_X[j], NAV_Y[j]);
            }
            n += 1;
        }
        i += 1;
    }
    set_alpha(255);

    // Desenha nos.
    i = 0;
    while (i < NAV_COUNT)
    {
        set_color(140, 245, 255);
        draw_circle(NAV_X[i], NAV_Y[i], 5, true);
        set_color(25, 45, 56);
        draw_circle(NAV_X[i], NAV_Y[i], 5, false);
        i += 1;
    }
}

def fx_burst(px, py, n, r, g, b)
{
    var i = 0;
    while (i < n)
    {
        fx_particle(px, py, r, g, b);
        i += 1;
    }
}

process fx_particle(px, py, r, g, b)
{
    x = px;
    y = py;
    var a = math.rand(0, 360);
    var sp = math.rand(80, 320);
    var vx = get_distx(a, sp);
    var vy = get_disty(a, sp);
    var life = math.rand(0.10, 0.30);
    var max_life = life;
    var size = math.rand(2, 5);

    loop
    {
        var dt = delta();
        life -= dt;
        if (life <= 0) break;

        x += vx * dt;
        y += vy * dt;
        vy += 780 * dt;
        vx *= (1.0 - dt * 2.5);

        set_alpha(int(255 * (life / max_life)));
        set_color(r, g, b);
        draw_circle(x, y, size * (life / max_life), true);
        set_alpha(255);
        frame;
    }
}

process fx_ring(px, py, r, g, b, radius_from, radius_to, duration)
{
    x = px;
    y = py;
    var t = 0.0;
    var dur = duration;
    if (dur < 0.01) dur = 0.01;

    loop
    {
        var dt = delta();
        t += dt;
        if (t >= dur) break;

        var k = t / dur;
        var RAD = radius_from + (radius_to - radius_from) * k;
        set_alpha(int(255 * (1.0 - k)));
        set_color(r, g, b);
        draw_circle(x, y, RAD, false);
        set_alpha(255);
        frame;
    }
}

process drift_mark(x1, y1, x2, y2)
{
    var life = 0.85;
    var max_life = life;
    var dx = x2 - x1;
    var dy = y2 - y1;
    var _len = sqrt(dx * dx + dy * dy);
    var nx = 0;
    var ny = 0;
    if (_len > 0.001)
    {
        nx = -dy / _len;
        ny = dx / _len;
    }

    loop
    {
        var dt = delta();
        life -= dt;
        if (life <= 0) break;

        var t = life / max_life;
        set_alpha(int(220 * t));
        set_color(48, 48, 56);
        draw_line(x1, y1, x2, y2);
        draw_line(x1 + nx, y1 + ny, x2 + nx, y2 + ny);
        draw_line(x1 - nx, y1 - ny, x2 - nx, y2 - ny);
        set_alpha(255);
        frame;
    }
}

def draw_backdrop(_camx, _camy)
{
    set_color(16, 20, 32);
    draw_rectangle(_camx, _camy, VIEW_W, VIEW_H, true);

    // Grid.
    set_color(30, 38, 56);
    var gx = int(_camx / 64) * 64;
    while (gx < _camx + VIEW_W + 64)
    {
        draw_line(gx, _camy, gx, _camy + VIEW_H);
        gx += 64;
    }
    var gy = int(_camy / 64) * 64;
    while (gy < _camy + VIEW_H + 64)
    {
        draw_line(_camx, gy, _camx + VIEW_W, gy);
        gy += 64;
    }

    // Quadras escuras para look de cidade.
    set_alpha(70);
    set_color(8, 10, 16);
    var bx = int(_camx / 320) * 320;
    while (bx < _camx + VIEW_W + 320)
    {
        var by = int(_camy / 240) * 240;
        while (by < _camy + VIEW_H + 240)
        {
            draw_rectangle(bx + 18, by + 18, 180, 120, true);
            by += 240;
        }
        bx += 320;
    }
    set_alpha(255);
}

process wall_block(px, py, w, h, r, g, b)
{
    x = px;
    y = py;
    z=0;

    set_rect_shape(0, 0, w, h);
    set_collision_layer(1);
    set_collision_mask(4);

    loop
    {
        set_color(r - 20, g - 20, b - 20);
        draw_rectangle(x - w / 2, y - h / 2, w, h, true);
        set_color(r, g, b);
        draw_rectangle(x - w / 2 + 2, y - h / 2 + 2, w - 4, h - 4, true);
        set_color(28, 34, 46);
        draw_rectangle(x - w / 2, y - h / 2, w, h, false);
        frame;
    }
}

process boost_pad(px, py)
{
    x = px;
    y = py;
    set_rect_shape(0, 0, 54, 30);
    set_collision_layer(3);
    set_collision_mask(0);

    loop
    {
        var t = time() * 8 + x * 0.02;
        var pulse = 0.5 + (sin(t) + 1) * 0.5;
        set_alpha(100 + int(pulse * 80));
        set_color(90, 180, 255);
        draw_rectangle(x - 27, y - 15, 54, 30, true);
        set_alpha(255);
        set_color(180, 230, 255);
        draw_rectangle(x - 21, y - 11, 42, 6, true);
        draw_rectangle(x - 21, y - 1, 42, 6, true);
        draw_rectangle(x - 21, y + 9, 42, 6, true);
        frame;
    }
}

process enemy_car(px, py, start_wp)
{
    x = px;
    y = py;
    set_rect_shape(0, 0, 34, 20);
    set_collision_layer(2);
    set_collision_mask(2);

    var hp = 4;
    var touch_cd = 0.0;
    var hit_flash = 0.0;
    angle = math.rand(0, 360);
    velx = 0.0;
    vely = 0.0;

    // IA por grafo.
    var wp_cur = start_wp;
    var wp_target = start_wp;
    var wp_next_step = start_wp;
    var repath_t = 0.0;
    var stuck_t = 0.0;
    var los_check_t = 0.0;
    var has_los = false;
    var bounce_cd = 0.0;
    var fire_cd = math.rand(0.35, 1.10);

    loop
    {
        var dt = delta();

        if (GAME_OVER)
        {
            set_color(90, 95, 110);
            draw_rotated_rectangle(x, y, 34, 20, -angle, true);
            frame;
            continue;
        }

        if (touch_cd > 0) touch_cd -= dt;
        if (hit_flash > 0) hit_flash -= dt;
        if (bounce_cd > 0) bounce_cd -= dt;
        if (fire_cd > 0) fire_cd -= dt;

        if (state > 0)
        {
            hp -= state;
            state = 0;
            hit_flash = 0.12;
            fx_burst(x, y, 6, 255, 130, 130);
            if (hp <= 0)
            {
                KILLS += 1;
                SCORE += 30;
                ENEMIES_ALIVE -= 1;
                fx_burst(x, y, 16, 255, 170, 170);
                fx_ring(x, y, 255, 170, 170, 4, 62, 0.22);
                if (math.rand(0.0, 1.0) < 0.22)
                {
                    pickup_orb(x, y, math.irand(0, 3));
                }
                break;
            }
        }

        var p = nil;
        if (PLAYER_ID != -1) p = proc(PLAYER_ID);

        // LOS check ao player (nao todos os frames, custa).
        los_check_t -= dt;
        if (p && los_check_t <= 0)
        {
            los_check_t = 0.20;
            has_los = line_free(x, y, p.x, p.y);
        }

        // Recalcula caminho periodicamente.
        repath_t -= dt;
        if (p && repath_t <= 0)
        {
            repath_t = 0.30;
            wp_cur = nav_find_nearest(x, y);
            wp_target = nav_find_nearest(p.x, p.y);
            wp_next_step = nav_next(wp_cur, wp_target);
        }

        // Avanca no grafo quando chega perto do waypoint seguinte.
        if (get_dist(x, y, NAV_X[wp_next_step], NAV_Y[wp_next_step]) < 60)
        {
            wp_cur = wp_next_step;
            if (wp_cur != wp_target)
            {
                wp_next_step = nav_next(wp_cur, wp_target);
            }
        }

        var target_x = NAV_X[wp_next_step];
        var target_y = NAV_Y[wp_next_step];

        // Se ve o player directamente, ignora waypoints.
        if (p && has_los)
        {
            target_x = p.x;
            target_y = p.y;
        }

        // Steering para o alvo.
        var desired_turn = 0.0;
        var target_a = get_angle(x, y, target_x, target_y);
        var d = target_a - angle;
        while (d > 180) d -= 360;
        while (d < -180) d += 360;
        desired_turn += math.clamp(d / 70, -1, 1);

        // Look-ahead anti-parede.
        var look_dist = 34 + math.clamp((abs(velx) + abs(vely)) * 0.05, 0, 20);
        var blocked_front = !place_free(x + get_distx(angle, look_dist),
                                        y + get_disty(angle, look_dist));
        var blocked_left = !place_free(x + get_distx(angle - 34, look_dist),
                                       y + get_disty(angle - 34, look_dist));
        var blocked_right = !place_free(x + get_distx(angle + 34, look_dist),
                                        y + get_disty(angle + 34, look_dist));

        if (blocked_front)
        {
            if (!blocked_left && blocked_right)
                desired_turn += 1.1;
            elif (!blocked_right && blocked_left)
                desired_turn -= 1.1;
            else
            {
                // Gira na direccao do alvo.
                if (d > 0) desired_turn += 1.0;
                else desired_turn -= 1.0;
            }
            velx -= get_distx(angle, 280 * dt);
            vely -= get_disty(angle, 280 * dt);
        }
        else
        {
            if (blocked_left && !blocked_right) desired_turn -= 0.40;
            if (blocked_right && !blocked_left) desired_turn += 0.40;
        }

        var turn_speed = 165;
        if (blocked_front) turn_speed = 320;
        angle += desired_turn * turn_speed * dt;

        var accel = 390;
        if (blocked_front) accel = 150;
        velx += get_distx(angle, accel * dt);
        vely += get_disty(angle, accel * dt);

        // Drift/friction.
        var fx = get_distx(angle, 1);
        var fy = get_disty(angle, 1);
        var rx = get_distx(angle + 90, 1);
        var ry = get_disty(angle + 90, 1);
        var side = velx * rx + vely * ry;
        velx -= rx * side * math.min(1.0, dt * 6.0);
        vely -= ry * side * math.min(1.0, dt * 6.0);
        velx *= (1.0 - dt * 0.70);
        vely *= (1.0 - dt * 0.70);

        var moved_x = false;
        var moved_y = false;

        var nx = x + velx * dt;
        if (place_free(nx, y))
        {
            x = nx;
            moved_x = true;
        }
        else
        {
            var sx = math.sign(velx);
            var steps_x = 0;
            while (sx != 0 && steps_x < 28 && place_free(x + sx, y))
            {
                x += sx;
                steps_x += 1;
                moved_x = true;
            }
            velx *= -0.18;
        }

        var ny = y + vely * dt;
        if (place_free(x, ny))
        {
            y = ny;
            moved_y = true;
        }
        else
        {
            var sy = math.sign(vely);
            var steps_y = 0;
            while (sy != 0 && steps_y < 28 && place_free(x, y + sy))
            {
                y += sy;
                steps_y += 1;
                moved_y = true;
            }
            vely *= -0.18;
        }

        if (!moved_x && !moved_y)
        {
            stuck_t += dt;
            velx *= 0.70;
            vely *= 0.70;

            if (stuck_t > 0.8)
            {
                // Preso ha muito tempo: recuo forte + gira 180.
                angle += 180;
                velx = get_distx(angle, 200);
                vely = get_disty(angle, 200);
                stuck_t = 0;
                repath_t = 0; // forca recalculo do caminho
            }
            else
            {
                // Gira na direccao do alvo e recua.
                if (d > 0) angle += 280 * dt;
                else angle -= 280 * dt;
                velx -= get_distx(angle, 200 * dt);
                vely -= get_disty(angle, 200 * dt);
            }
        }
        else
        {
            if (stuck_t > 0) stuck_t -= dt * 2;
            if (stuck_t < 0) stuck_t = 0;
        }

        // Failsafe: se entrou em parede por choque/canto, empurra para fora.
        if (!place_free(x, y))
        {
            var out_e = find_free_spot(x, y, 46);
            if (out_e[2] == 1)
            {
                x = out_e[0];
                y = out_e[1];
                velx *= 0.62;
                vely *= 0.62;
                repath_t = 0;
            }
            else
            {
                x = x - get_distx(angle, 6);
                y = y - get_disty(angle, 6);
                velx *= -0.20;
                vely *= -0.20;
                repath_t = 0;
            }
        }

        // Colisao + bounce entre inimigos (sem bloquear navegação por place_free).
        if (bounce_cd <= 0)
        {
            var e2 = collision(type enemy_car, x, y);
            if (e2 && e2.id != id && e2.id > id)
            {
                var dx2 = x - e2.x;
                var dy2 = y - e2.y;
                var d2 = sqrt(dx2 * dx2 + dy2 * dy2);

                if (d2 < CAR_HIT_RADIUS)
                {
                    if (d2 < 0.001)
                    {
                        dx2 = 1;
                        dy2 = 0;
                        d2 = 1;
                    }

                    var nx2 = dx2 / d2;
                    var ny2 = dy2 / d2;

                    var push2 = (CAR_HIT_RADIUS - d2) * 0.5 + 2;
                    x += nx2 * push2;
                    y += ny2 * push2;
                    e2.x -= nx2 * push2;
                    e2.y -= ny2 * push2;

                    // Evita empurrar carros para dentro de parede.
                    if (!place_free(x, y))
                    {
                        var out_self = find_free_spot(x, y, 34);
                        if (out_self[2] == 1)
                        {
                            x = out_self[0];
                            y = out_self[1];
                        }
                    }
                    if (!place_free(e2.x, e2.y))
                    {
                        var out_e2 = find_free_spot(e2.x, e2.y, 34);
                        if (out_e2[2] == 1)
                        {
                            e2.x = out_e2[0];
                            e2.y = out_e2[1];
                        }
                    }

                    var rel2 = (velx - e2.velx) * nx2 + (vely - e2.vely) * ny2;
                    var imp2 = CAR_BOUNCE_IMPULSE;
                    if (rel2 < 0) imp2 += (-rel2) * 0.6;

                    velx += nx2 * imp2;
                    vely += ny2 * imp2;
                    e2.velx -= nx2 * imp2;
                    e2.vely -= ny2 * imp2;

                    velx *= 0.85;
                    vely *= 0.85;
                    e2.velx *= 0.85;
                    e2.vely *= 0.85;

                    bounce_cd = 0.08;
                    fx_burst(x - nx2 * 8, y - ny2 * 8, 3, 180, 220, 255);
                }
            }
        }

        // Tiro inimigo quando tem visao.
        if (p && has_los && fire_cd <= 0 && get_dist(x, y, p.x, p.y) < 760)
        {
            var shoot_a = get_angle(x, y, p.x, p.y) + math.rand(-5, 5);
            var muzzle_x = x + get_distx(angle, 18);
            var muzzle_y = y + get_disty(angle, 18);
            enemy_bullet(muzzle_x, muzzle_y, shoot_a);
            fx_burst(muzzle_x, muzzle_y, 4, 255, 150, 130);
            fire_cd = math.rand(0.75, 1.45);
        }

        if (p && touch_cd <= 0 && get_dist(x, y, p.x, p.y) < 24)
        {
            p.state += 1;
            touch_cd = 0.6;
        }

        // Enemy body: warm copper/orange, high contrast on dark map.
        if (hit_flash > 0) set_color(255, 212, 120);
        else set_color(244, 126, 74);
        draw_rotated_rectangle(x, y, 34, 20, -angle, true);
        set_color(255, 232, 166);
        draw_rotated_rectangle(x, y, 14, 7, -angle, true);
        set_color(58, 24, 16);
        draw_rotated_rectangle(x, y, 34, 20, -angle, false);

        // Wheels: front + rear for better silhouette/readability.
        var wheel_len = 8;
        var wheel_w = 4;
        var axle_front = 10;
        var axle_rear = 10;
        var track = 9;

        var front_cx = x + get_distx(angle, axle_front);
        var front_cy = y + get_disty(angle, axle_front);
        var rear_cx = x + get_distx(angle + 180, axle_rear);
        var rear_cy = y + get_disty(angle + 180, axle_rear);

        var f_lx = front_cx + get_distx(angle - 90, track);
        var f_ly = front_cy + get_disty(angle - 90, track);
        var f_rx = front_cx + get_distx(angle + 90, track);
        var f_ry = front_cy + get_disty(angle + 90, track);

        var r_lx = rear_cx + get_distx(angle - 90, track);
        var r_ly = rear_cy + get_disty(angle - 90, track);
        var r_rx = rear_cx + get_distx(angle + 90, track);
        var r_ry = rear_cy + get_disty(angle + 90, track);

        set_color(28, 18, 18);
        draw_rotated_rectangle(f_lx, f_ly, wheel_len, wheel_w, -angle, true);
        draw_rotated_rectangle(f_rx, f_ry, wheel_len, wheel_w, -angle, true);
        draw_rotated_rectangle(r_lx, r_ly, wheel_len, wheel_w, -angle, true);
        draw_rotated_rectangle(r_rx, r_ry, wheel_len, wheel_w, -angle, true);
        set_color(160, 120, 95);
        draw_rotated_rectangle(f_lx, f_ly, wheel_len, wheel_w, -angle, false);
        draw_rotated_rectangle(f_rx, f_ry, wheel_len, wheel_w, -angle, false);
        draw_rotated_rectangle(r_lx, r_ly, wheel_len, wheel_w, -angle, false);
        draw_rotated_rectangle(r_rx, r_ry, wheel_len, wheel_w, -angle, false);

        // Gun barrel: visible tube + muzzle tip.
        var gun_base_x = x + get_distx(angle, 10);
        var gun_base_y = y + get_disty(angle, 10);
        var gun_tip_x = x + get_distx(angle, 22);
        var gun_tip_y = y + get_disty(angle, 22);
        set_color(255, 244, 210);
        draw_line_ex(gun_base_x, gun_base_y, gun_tip_x, gun_tip_y, 3);
        set_color(95, 44, 28);
        draw_circle(gun_tip_x, gun_tip_y, 2, true);

        // HP bar above enemy for readability.
        set_color(10, 10, 14);
        draw_rectangle(x - 12, y - 18, 24, 4, true);
        set_color(255, 224, 84);
        draw_rectangle(x - 12, y - 18, 24 * (hp / 4), 4, true);
        set_color(255, 245, 180);
        draw_rectangle(x - 12, y - 18, 24, 4, false);

        frame;
    }
}

process player_bullet(px, py, ang)
{
    x = px;
    y = py;
    z=3;
    set_circle_shape(4);
    set_collision_layer(4);
    set_collision_mask(0);

    var speed_b = 980;
    var life = 1.0;

    loop
    {
        var dt = delta();
        life -= dt;
        if (life <= 0) break;

        x += get_distx(ang, speed_b) * dt;
        y += get_disty(ang, speed_b) * dt;

        if (x < -40 || x > WORLD_W + 40 || y < -40 || y > WORLD_H + 40)
        {
            break;
        }

        var w = collision(type wall_block, x, y);
        if (w)
        {
            fx_burst(x, y, 5, 255, 210, 130);
            break;
        }

        var e = collision(type enemy_car, x, y);
        if (e)
        {
            e.state += 1;
            fx_burst(x, y, 8, 255, 225, 140);
            break;
        }

        set_alpha(90);
        set_color(255, 220, 120);
        draw_circle(x, y, 8, true);
        set_alpha(255);
        set_color(255, 245, 190);
        draw_circle(x, y, 4, true);
        frame;
    }
}

process enemy_bullet(px, py, ang)
{
    x = px;
    y = py;
    z = 3;
    set_circle_shape(4);
    set_collision_layer(6);
    set_collision_mask(0);

    var speed_b = 760;
    var life = 2.0;

    loop
    {
        var dt = delta();
        life -= dt;
        if (life <= 0) break;

        x += get_distx(ang, speed_b) * dt;
        y += get_disty(ang, speed_b) * dt;

        if (x < -40 || x > WORLD_W + 40 || y < -40 || y > WORLD_H + 40)
        {
            break;
        }

        var w = collision(type wall_block, x, y);
        if (w)
        {
            fx_burst(x, y, 4, 255, 140, 110);
            break;
        }

        var p = collision(type player_car, x, y);
        if (p)
        {
            p.state += ENEMY_BULLET_DAMAGE;
            fx_burst(x, y, 7, 255, 120, 120);
            fx_ring(x, y, 255, 170, 170, 2, 18, 0.14);
            break;
        }

        set_alpha(90);
        set_color(255, 120, 110);
        draw_circle(x, y, 7, true);
        set_alpha(255);
        set_color(255, 210, 180);
        draw_circle(x, y, 3, true);
        frame;
    }
}

process player_car(px, py)
{
    x = px;
    y = py;
    xold = x;
    yold = y;

    set_rect_shape(0, 0, 36, 22);
    set_collision_layer(2);
    set_collision_mask(2); // walls only (enemy contact handled by distance)

    angle = -90;
    velx = 0.0;
    vely = 0.0;
    speed = 0.0;
    var fire_cd = 0.0;
    var hurt_cd = 0.0;
    var boost_cd = 0.0;
    var boost_t = 0.0;
    var trail_cd = 0.0;
    var skid_cd = 0.0;
    var wall_shake_cd = 0.0;
    var car_hit_cd = 0.0;

    loop
    {
        var dt = delta();
        xold = x;
        yold = y;
        var angle_old = angle;
        ensure_touch_ui_runtime();
        joystick_update();

        var mx = get_mouse_x() + CAM_X;
        var my = get_mouse_y() + CAM_Y;
        var touch_aim = get_aim_touch_screen();
        if (touch_count() > 0)
        {
            if (touch_aim[2] == 1)
            {
                mx = touch_aim[0] + CAM_X;
                my = touch_aim[1] + CAM_Y;
            }
            else
            {
                // If there is no dedicated aim touch, shoot forward.
                mx = x + get_distx(angle, 240);
                my = y + get_disty(angle, 240);
            }
        }
        var aim = get_angle(x, y, mx, my);

        if (!GAME_OVER)
        {
            if (fire_cd > 0) fire_cd -= dt;
            if (hurt_cd > 0) hurt_cd -= dt;
            if (boost_cd > 0) boost_cd -= dt;
            if (boost_t > 0) boost_t -= dt;
            if (trail_cd > 0) trail_cd -= dt;
            if (skid_cd > 0) skid_cd -= dt;
            if (wall_shake_cd > 0) wall_shake_cd -= dt;
            if (car_hit_cd > 0) car_hit_cd -= dt;
            if (PLAYER_RAPID_TIMER > 0) PLAYER_RAPID_TIMER -= dt;
            if (PLAYER_SHIELD_TIMER > 0) PLAYER_SHIELD_TIMER -= dt;
            if (PLAYER_OVERDRIVE_TIMER > 0) PLAYER_OVERDRIVE_TIMER -= dt;

            var throttle = 0.0;
            if (key_down(KEY_W) || key_down(KEY_UP)) throttle += 1;
            if (key_down(KEY_S) || key_down(KEY_DOWN)) throttle -= 1;

            var steer = 0.0;
            if (key_down(KEY_A) || key_down(KEY_LEFT)) steer -= 1;
            if (key_down(KEY_D) || key_down(KEY_RIGHT)) steer += 1;
            if (touch_count() > 0 && JOY_ACTIVE) steer = JOY_AXIS_X;

            var fx = get_distx(angle, 1);
            var fy = get_disty(angle, 1);
            var rx = get_distx(angle + 90, 1);
            var ry = get_disty(angle + 90, 1);
            var forward_v = velx * fx + vely * fy;
            var side_v = velx * rx + vely * ry;

            // Direcao do volante depende se vai para frente ou tras.
            var steer_dir = 1;
            if (forward_v < -8) steer_dir = -1;

            var turn_rate = 220;
            var speed_factor = math.clamp(abs(forward_v) / 420, 0.25, 1.2);
            angle -= steer * steer_dir * turn_rate * speed_factor * dt;

            var accel = 650;
            if (throttle > 0) { velx += fx * accel * dt; vely += fy * accel * dt; }
            if (throttle < 0) { velx -= fx * (accel * 0.92) * dt; vely -= fy * (accel * 0.92) * dt; }

            if (key_pressed(KEY_SHIFT) && boost_cd <= 0)
            {
                boost_t = 0.24;
                boost_cd = 0.85;
                fx_burst(x, y, 10, 140, 220, 255);
                start_camera_shake(-2, -2, 24, 12);
            }
            if (boost_t > 0)
            {
                var boost_mul = 1.0;
                if (PLAYER_OVERDRIVE_TIMER > 0) boost_mul = 1.35;
                velx += fx * 1200 * boost_mul * dt;
                vely += fy * 1200 * boost_mul * dt;
            }

            // Grip/lateral damping (drift).
            var grip = 8.0;
            if (key_down(KEY_SPACE)) grip = 3.2; // handbrake drift
            velx -= rx * side_v * math.min(1.0, dt * grip);
            vely -= ry * side_v * math.min(1.0, dt * grip);

            // Drag.
            velx *= (1.0 - dt * 0.55);
            vely *= (1.0 - dt * 0.55);

            // Limites de velocidade.
            var maxf = 620;
            var maxr = 430;
            forward_v = velx * fx + vely * fy;
            if (forward_v > maxf)
            {
                var cut = (forward_v - maxf);
                velx -= fx * cut;
                vely -= fy * cut;
            }
            if (forward_v < -maxr)
            {
                var cut2 = (-maxr - forward_v);
                velx += fx * cut2;
                vely += fy * cut2;
            }

            var moved_x = false;
            var moved_y = false;

            var nx = x + velx * dt;
            if (place_free(nx, y))
            {
                x = nx;
                moved_x = true;
            }
            else
            {
                var hit_px = x + math.sign(velx) * 18;
                var hit_py = y + math.clamp(vely * 0.03, -8, 8);
                var hit_power = abs(velx) + abs(vely) * 0.30;

                var sx = math.sign(velx);
                var steps_x = 0;
                while (sx != 0 && steps_x < 34 && place_free(x + sx, y))
                {
                    x += sx;
                    steps_x += 1;
                    moved_x = true;
                }
                // Wall slide: redirect parte da velocidade bloqueada para o eixo livre.
                vely += velx * 0.12;
                velx *= -0.28;
                fx_burst(hit_px, hit_py, 9, 255, 170, 120);
                if (wall_shake_cd <= 0 && hit_power > 110)
                {
                    start_camera_shake(-2, -2, 22, 9);
                    wall_shake_cd = 0.08;
                }
            }

            var ny = y + vely * dt;
            if (place_free(x, ny))
            {
                y = ny;
                moved_y = true;
            }
            else
            {
                var hit_px = x + math.clamp(velx * 0.03, -8, 8);
                var hit_py = y + math.sign(vely) * 11;
                var hit_power = abs(vely) + abs(velx) * 0.30;

                var sy = math.sign(vely);
                var steps_y = 0;
                while (sy != 0 && steps_y < 34 && place_free(x, y + sy))
                {
                    y += sy;
                    steps_y += 1;
                    moved_y = true;
                }
                // Wall slide: redirect parte da velocidade bloqueada para o eixo livre.
                velx += vely * 0.12;
                vely *= -0.28;
                fx_burst(hit_px, hit_py, 9, 255, 170, 120);
                if (wall_shake_cd <= 0 && hit_power > 110)
                {
                    start_camera_shake(-2, -2, 22, 9);
                    wall_shake_cd = 0.08;
                }
            }

            if (!moved_x && !moved_y)
            {
                if (throttle < 0)
                {
                    // Assist de marcha-atrás quando preso em canto.
                    velx -= fx * 260 * dt;
                    vely -= fy * 260 * dt;
                }

                // Preso em ambos eixos: tenta movimento diagonal.
                if (place_free(x + velx * dt, y + vely * dt))
                {
                    x += velx * dt;
                    y += vely * dt;
                }
                else
                {
                    // Procura direccao livre nas 8 dir e empurra para la.
                    var esc_a = 0;
                    var esc_found = false;
                    while (esc_a < 360)
                    {
                        if (place_free(x + get_distx(esc_a, 5), y + get_disty(esc_a, 5)))
                        {
                            x += get_distx(esc_a, 2);
                            y += get_disty(esc_a, 2);
                            velx = get_distx(esc_a, 80);
                            vely = get_disty(esc_a, 80);
                            esc_found = true;
                            break;
                        }
                        esc_a += 45;
                    }
                    if (!esc_found)
                    {
                        velx *= 0.78;
                        vely *= 0.78;
                    }
                }
            }

            // Failsafe final: se entrou em parede (corner case), descola do solido.
            if (!place_free(x, y))
            {
                var out_p = find_free_spot(x, y, 50);
                if (out_p[2] == 1)
                {
                    x = out_p[0];
                    y = out_p[1];
                    velx *= 0.58;
                    vely *= 0.58;
                }
                else
                {
                    x = xold;
                    y = yold;
                    velx *= -0.18;
                    vely *= -0.18;
                }
            }

            // Colisao + bounce player vs enemy.
            if (car_hit_cd <= 0)
            {
                var hit_enemy = collision(type enemy_car, x, y);
                if (hit_enemy)
                {
                    var dxp = x - hit_enemy.x;
                    var dyp = y - hit_enemy.y;
                    var dp = sqrt(dxp * dxp + dyp * dyp);

                    if (dp < CAR_HIT_RADIUS)
                    {
                        if (dp < 0.001)
                        {
                            dxp = get_distx(angle, 1);
                            dyp = get_disty(angle, 1);
                            dp = 1;
                        }

                        var nxp = dxp / dp;
                        var nyp = dyp / dp;

                        var pushp = (CAR_HIT_RADIUS - dp) * 0.7 + 2;
                        x += nxp * pushp;
                        y += nyp * pushp;
                        hit_enemy.x -= nxp * (pushp * 0.8);
                        hit_enemy.y -= nyp * (pushp * 0.8);

                        var speed_push = math.clamp(speed * 0.45, 80, 260);
                        var imp_p = CAR_BOUNCE_IMPULSE + speed_push;

                        velx += nxp * imp_p;
                        vely += nyp * imp_p;
                        hit_enemy.velx -= nxp * imp_p * 0.9;
                        hit_enemy.vely -= nyp * imp_p * 0.9;

                        velx *= 0.82;
                        vely *= 0.82;
                        hit_enemy.velx *= 0.88;
                        hit_enemy.vely *= 0.88;

                        state += 1;
                        car_hit_cd = 0.12;

                        fx_burst(x - nxp * 8, y - nyp * 8, 8, 255, 190, 140);
                        start_camera_shake(-2, -2, 22, 8);
                    }
                }
            }

            // Marcas de drift (rodas traseiras), no mesmo referencial do debug.
            var drifting = (key_down(KEY_SPACE) || abs(side_v) > 42) && abs(forward_v) > 55;
            if (drifting && skid_cd <= 0)
            {
                skid_cd = 0.015;

                var rear_off = 14;
                var track = 8;
                var mark_angle_old = angle_old;
                var mark_angle_new = angle;

                var old_rx = xold + get_distx(mark_angle_old + 180, rear_off);
                var old_ry = yold + get_disty(mark_angle_old + 180, rear_off);
                var new_rx = x + get_distx(mark_angle_new + 180, rear_off);
                var new_ry = y + get_disty(mark_angle_new + 180, rear_off);

                var old_lx = old_rx + get_distx(mark_angle_old - 90, track);
                var old_ly = old_ry + get_disty(mark_angle_old - 90, track);
                var new_lx = new_rx + get_distx(mark_angle_new - 90, track);
                var new_ly = new_ry + get_disty(mark_angle_new - 90, track);

                var old_rx2 = old_rx + get_distx(mark_angle_old + 90, track);
                var old_ry2 = old_ry + get_disty(mark_angle_old + 90, track);
                var new_rx2 = new_rx + get_distx(mark_angle_new + 90, track);
                var new_ry2 = new_ry + get_disty(mark_angle_new + 90, track);

                drift_mark(old_lx, old_ly, new_lx, new_ly);
                drift_mark(old_rx2, old_ry2, new_rx2, new_ry2);
       
            }

            // Boost pad.
            var pad = collision(type boost_pad, x, y);
            if (pad)
            {
                velx += fx * 720 * dt;
                vely += fy * 720 * dt;
                if (trail_cd <= 0)
                {
                    trail_cd = 0.08;
                    fx_burst(x, y, 4, 120, 220, 255);
                }
            }

            // Em touch platform dispara apenas no botão FIRE.
            var shoot_hold = false;
            if (TOUCH_UI_ENABLED) shoot_hold = key_down(KEY_FIRE);
            else shoot_hold = (mouse_down(0) || key_down(KEY_FIRE));

            if (shoot_hold && fire_cd <= 0)
            {
                var fire_step = 0.08;
                if (PLAYER_RAPID_TIMER > 0) fire_step = 0.045;
                if (PLAYER_OVERDRIVE_TIMER > 0) fire_step = 0.030;
                fire_cd = fire_step;
                var muzzle_len = 20;
                var muzzle_x = x + get_distx(aim, muzzle_len);
                var muzzle_y = y + get_disty(aim, muzzle_len);
                player_bullet(muzzle_x, muzzle_y, aim);
                if (PLAYER_OVERDRIVE_TIMER > 0)
                {
                    player_bullet(muzzle_x, muzzle_y, aim - 6);
                    player_bullet(muzzle_x, muzzle_y, aim + 6);
                }
                fx_burst(muzzle_x, muzzle_y, 3, 255, 230, 170);
                if (PLAYER_OVERDRIVE_TIMER > 0)
                {
                    fx_ring(muzzle_x, muzzle_y, 255, 140, 220, 2, 18, 0.10);
                }
            }

            if (state > 0 && hurt_cd <= 0)
            {
                if (PLAYER_SHIELD_TIMER > 0)
                {
                    state = 0;
                    hurt_cd = 0.08;
                    fx_burst(x, y, 8, 140, 220, 255);
                    fx_ring(x, y, 120, 220, 255, 8, 30, 0.16);
                }
                else
                {
                    state = 0;
                    hurt_cd = 0.6;
                    HP -= 1;
                    fx_burst(x, y, 14, 255, 120, 120);
                    start_camera_shake(-3, -3, 24, 16);
                    if (HP <= 0)
                    {
                        HP = 0;
                        GAME_OVER = true;
                    }
                }
            }
            else
            {
                state = 0;
            }

            if (PLAYER_OVERDRIVE_TIMER > 0 && trail_cd <= 0)
            {
                trail_cd = 0.045;
                fx_burst(x - get_distx(angle, 14), y - get_disty(angle, 14), 2, 255, 130, 220);
            }
        }

        speed = sqrt(velx * velx + vely * vely);

        // Carro player.
        var body_r = 98;
        var body_g = 176;
        var body_b = 255;
        if (hurt_cd > 0)
        {
            body_r = 255;
            body_g = 130;
            body_b = 130;
        }

        var draw_angle = -angle;
        set_color(body_r, body_g, body_b);
        draw_rotated_rectangle(x , y , 36, 22, draw_angle, true);
        set_color(30, 38, 56);
        draw_rotated_rectangle(x , y , 36, 22, draw_angle, false);

        // Debug: pontos onde as marcas de drift devem aparecer (rodas traseiras).
        var rear_off_dbg = 14;
        var track_dbg = 8;
        var draw_angle_dbg = -draw_angle ;
        var rear_x_dbg = x + get_distx(draw_angle_dbg + 180, rear_off_dbg);
        var rear_y_dbg = y + get_disty(draw_angle_dbg + 180, rear_off_dbg);
        var skid_lx_dbg = rear_x_dbg + get_distx(draw_angle_dbg - 90, track_dbg);
        var skid_ly_dbg = rear_y_dbg + get_disty(draw_angle_dbg - 90, track_dbg);
        var skid_rx_dbg = rear_x_dbg + get_distx(draw_angle_dbg + 90, track_dbg);
        var skid_ry_dbg = rear_y_dbg + get_disty(draw_angle_dbg + 90, track_dbg);

        set_color(24, 28, 38);
        draw_circle(skid_lx_dbg, skid_ly_dbg, 3, true);
        draw_circle(skid_rx_dbg, skid_ry_dbg, 3, true);
        set_color(95, 110, 145);
        draw_circle(skid_lx_dbg, skid_ly_dbg, 3, false);
        draw_circle(skid_rx_dbg, skid_ry_dbg, 3, false);
        // Rodas da frente (2 retangulos).
        var wheel_angle = -draw_angle;
        var front_off = 14;
        var front_track = 9;
        var front_cx = x + get_distx(wheel_angle, front_off);
        var front_cy = y + get_disty(wheel_angle, front_off);
        var wheel_lx = front_cx + get_distx(wheel_angle - 90, front_track);
        var wheel_ly = front_cy + get_disty(wheel_angle - 90, front_track);
        var wheel_rx = front_cx + get_distx(wheel_angle + 90, front_track);
        var wheel_ry = front_cy + get_disty(wheel_angle + 90, front_track);

        set_color(24, 28, 38);
        draw_rotated_rectangle(wheel_lx, wheel_ly, 8, 4, draw_angle, true);
        draw_rotated_rectangle(wheel_rx, wheel_ry, 8, 4, draw_angle, true);
        set_color(95, 110, 145);
        draw_rotated_rectangle(wheel_lx, wheel_ly, 8, 4, draw_angle, false);
        draw_rotated_rectangle(wheel_rx, wheel_ry, 8, 4, draw_angle, false);


        // canhao no centro do carro, apontado para o rato.
        var barrel_len = 20;
        var bx = x + get_distx(aim, barrel_len);
        var by = y + get_disty(aim, barrel_len);
        set_color(80, 90, 120);
        draw_line_ex(x, y, bx, by, 5);
        set_color(130, 140, 170);
        draw_line_ex(x, y, bx, by, 2);
        set_color(55, 62, 82);
        draw_circle(x, y, 5, true);

        if (PLAYER_SHIELD_TIMER > 0)
        {
            set_alpha(140 + int((sin(time() * 12) + 1) * 45));
            set_color(120, 220, 255);
            draw_circle(x, y, 24, false);
            set_alpha(255);
        }

        // Crosshair
        set_color(255, 230, 160);
        draw_circle(mx, my, 8, false);
        draw_line(mx - 12, my, mx - 4, my);
        draw_line(mx + 4, my, mx + 12, my);
        draw_line(mx, my - 12, mx, my - 4);
        draw_line(mx, my + 4, mx, my + 12);

        frame;
    }
}

process pickup_orb(px, py, ptype)
{
    x = px;
    y = py;
    set_circle_shape(12);
    set_collision_layer(5);
    set_collision_mask(0);
    var life = 18.0;
    var spin = math.rand(0, 360);

    loop
    {
        var dt = delta();
        if (GAME_OVER) break;

        life -= dt;
        if (life <= 0) break;
        spin += dt * 220;

        var pulse = 0.55 + (sin(time() * 8 + x * 0.01) + 1) * 0.45;
        var rr = 120;
        var gg = 180;
        var bb = 255;
        var letter = "R";

        if (ptype == PICKUP_HEAL)
        {
            rr = 120; gg = 255; bb = 150; letter = "H";
        }
        elif (ptype == PICKUP_RAPID)
        {
            rr = 255; gg = 220; bb = 110; letter = "R";
        }
        elif (ptype == PICKUP_SHIELD)
        {
            rr = 130; gg = 220; bb = 255; letter = "S";
        }
        else
        {
            rr = 255; gg = 120; bb = 220; letter = "O";
        }

        var p = collision(type player_car, x, y);
        if (p)
        {
            if (ptype == PICKUP_HEAL)
            {
                HP += 3;
                if (HP > HP_MAX) HP = HP_MAX;
            }
            elif (ptype == PICKUP_RAPID)
            {
                if (PLAYER_RAPID_TIMER < 8.0) PLAYER_RAPID_TIMER = 8.0;
            }
            elif (ptype == PICKUP_SHIELD)
            {
                if (PLAYER_SHIELD_TIMER < 7.0) PLAYER_SHIELD_TIMER = 7.0;
            }
            else
            {
                if (PLAYER_OVERDRIVE_TIMER < 7.0) PLAYER_OVERDRIVE_TIMER = 7.0;
                if (PLAYER_RAPID_TIMER < 4.0) PLAYER_RAPID_TIMER = 4.0;
            }

            SCORE += 15;
            fx_burst(x, y, 14, rr, gg, bb);
            fx_ring(x, y, rr, gg, bb, 4, 54, 0.24);
            start_camera_shake(-2, -2, 28, 8);
            break;
        }

        set_alpha(int(150 + pulse * 100));
        set_color(rr, gg, bb);
        draw_circle(x, y, 10 + pulse * 5, true);
        set_alpha(255);

        set_color(255, 255, 255);
        draw_circle(x, y, 8 + pulse * 2, false);
        draw_text(letter, x - 5, y - 9, 16);

        // pequena orbita visual
        var ox = x + get_distx(spin, 14);
        var oy = y + get_disty(spin, 14);
        set_alpha(160);
        set_color(rr, gg, bb);
        draw_circle(ox, oy, 3, true);
        set_alpha(255);

        frame;
    }
}

process pickup_spawner()
{
    var timer = 3.5;

    loop
    {
        var dt = delta();
        if (GAME_OVER)
        {
            frame;
            continue;
        }

        timer -= dt;
        if (timer <= 0)
        {
            timer = math.rand(4.5, 8.5);

            if (count_processes(type pickup_orb) < 4)
            {
                var p = nil;
                if (PLAYER_ID != -1) p = proc(PLAYER_ID);

                var idx = 0;
                var px = NAV_X[0];
                var py = NAV_Y[0];
                var tries = 0;

                while (tries < 10)
                {
                    idx = math.irand(0, NAV_COUNT - 1);
                    px = NAV_X[idx];
                    py = NAV_Y[idx];
                    if (!p || get_dist(px, py, p.x, p.y) > 300)
                    {
                        break;
                    }
                    tries += 1;
                }

                pickup_orb(px, py, math.irand(0, 3));
                fx_ring(px, py, 120, 220, 255, 2, 24, 0.18);
            }
        }

        frame;
    }
}

// Waypoints bons para spawn (longe do player start em WP0).
var SPAWN_WPS = [3, 8, 11, 14, 17, 18, 19];
var SPAWN_COUNT = 7;

// Waypoints seguros para spawn do player.
var PLAYER_SPAWN_WPS = [0, 1, 2, 4, 5, 6, 7, 9, 10, 12, 13, 15, 16];
var PLAYER_SPAWN_COUNT = 13;

process enemy_spawner()
{
    var timer = 0.0;
    var elapsed = 0.0;
    var base_interval = 1.15;
    var max_alive = 1;
    var growth_step_seconds = 24.0; // A cada 24s sobe o limite: 1, 2, 3...
    var max_alive_cap = 6;
    var idx = 0;

    // Primeiro inimigo aparece logo no começo da ronda.
    timer = base_interval;

    loop
    {
        var dt = delta();
        if (GAME_OVER)
        {
            frame;
            continue;
        }

        elapsed += dt;
        max_alive = 1 + int(elapsed / growth_step_seconds);
        if (max_alive > max_alive_cap) max_alive = max_alive_cap;

        var interval = base_interval - (max_alive - 1) * 0.06;
        if (interval < 0.55) interval = 0.55;

        timer += dt;
        if (timer >= interval && ENEMIES_ALIVE < max_alive)
        {
            timer = 0;
            var sw = SPAWN_WPS[idx % SPAWN_COUNT];
            var ex = NAV_X[sw];
            var ey = NAV_Y[sw];
            idx += 1;
            ENEMIES_ALIVE += 1;
            enemy_car(ex, ey, sw);
        }

        frame;
    }
}

  

def build_world()
{
    // Borda externa.
    wall_block(WORLD_W / 2, 16, WORLD_W, 32, 90, 102, 128);
    wall_block(WORLD_W / 2, WORLD_H - 16, WORLD_W, 32, 90, 102, 128);
    wall_block(16, WORLD_H / 2, 32, WORLD_H, 90, 102, 128);
    wall_block(WORLD_W - 16, WORLD_H / 2, 32, WORLD_H, 90, 102, 128);

    // Blocos internos (quadras).
    wall_block(540, 420, 520, 42, 102, 120, 150);
    wall_block(540, 860, 520, 42, 102, 120, 150);
    wall_block(280, 640, 42, 480, 102, 120, 150);
    wall_block(800, 640, 42, 480, 102, 120, 150);

    wall_block(1410, 360, 620, 42, 102, 120, 150);
    wall_block(1410, 920, 620, 42, 102, 120, 150);
    wall_block(1090, 640, 42, 600, 102, 120, 150);
    wall_block(1730, 640, 42, 600, 102, 120, 150);

    wall_block(2460, 440, 520, 42, 102, 120, 150);
    wall_block(2460, 880, 520, 42, 102, 120, 150);
    wall_block(2200, 660, 42, 480, 102, 120, 150);
    wall_block(2720, 660, 42, 480, 102, 120, 150);

    wall_block(830, 1540, 760, 42, 102, 120, 150);
    wall_block(830, 1980, 760, 42, 102, 120, 150);
    wall_block(450, 1760, 42, 480, 102, 120, 150);
    wall_block(1210, 1760, 42, 480, 102, 120, 150);

    wall_block(2250, 1500, 760, 42, 102, 120, 150);
    wall_block(2250, 2020, 760, 42, 102, 120, 150);
    wall_block(1870, 1760, 42, 560, 102, 120, 150);
    wall_block(2630, 1760, 42, 560, 102, 120, 150);

    // Boost pads.
    boost_pad(540, 640);
    boost_pad(1410, 640);
    boost_pad(2460, 640);
    boost_pad(830, 1760);
    boost_pad(2250, 1760);
}

def start_game()
{
    let_me_alone();
    GAME_OVER = false;
    SCORE = 0;
    KILLS = 0;
    HP = HP_MAX;
    ENEMIES_ALIVE = 0;
    PLAYER_ID = -1;
    CAM_X = 0;
    CAM_Y = 0;
    PLAYER_RAPID_TIMER = 0;
    PLAYER_SHIELD_TIMER = 0;
    PLAYER_OVERDRIVE_TIMER = 0;
    joystick_reset_state();


    build_world();
    enemy_spawner();
    pickup_spawner();
 

    var player_wp = PLAYER_SPAWN_WPS[math.irand(0, PLAYER_SPAWN_COUNT - 1)];
    var spawn_x = NAV_X[player_wp];
    var spawn_y = NAV_Y[player_wp];

    var p = player_car(spawn_x, spawn_y);
    if (p) PLAYER_ID = p.id;
}

set_window_size(VIEW_W, VIEW_H);
set_window_title("Topdown Chaos Cars");
set_design_resolution(VIEW_W, VIEW_H);
set_virtual_screen_enabled(true);
print(os.platform);
set_screen_scale_mode(1);
// if (os.platform== "emscripten" || os.platform == "desktop")
// {
//     set_screen_scale_mode(0);
// }
// else
// {
//     set_screen_scale_mode(1);
// }
init_collision(0, 0, WORLD_W, WORLD_H);
setup_touch_controls();

nav_precompute();
start_game();



loop
{
    var dt = delta();
    set_draw_screen(false);
    ensure_touch_ui_runtime();
    var p = nil;
    if (PLAYER_ID != -1) p = proc(PLAYER_ID);

    if (p)
    {
        var tx = p.x - VIEW_W * 0.5;
        var ty = p.y - VIEW_H * 0.5;
        tx = math.clamp(tx, 0, WORLD_W - VIEW_W);
        ty = math.clamp(ty, 0, WORLD_H - VIEW_H);
        CAM_X += (tx - CAM_X) * math.min(1.0, dt * 7.5);
        CAM_Y += (ty - CAM_Y) * math.min(1.0, dt * 7.5);
    }

    set_scroll(CAM_X, CAM_Y);
    draw_backdrop(CAM_X, CAM_Y);
    draw_waypoints_overlay();

 

        var spd = 0;
        if (p) spd = int(p.speed);

        // HUD/controles em screen-space por cima do mundo.
        set_draw_screen(true);

        // Compact HUD
        set_alpha(176);
        set_color(10, 14, 22);
        draw_rectangle(12, 10, 370, 118, true);
        set_alpha(255);
        set_color(82, 108, 162);
        draw_rectangle(12, 10, 370, 118, false);

        set_color(245, 248, 255);
        draw_text("CHAOS", 22, 18, 24);
        draw_text(format("SCR {}", SCORE), 22, 46, 18);
        draw_text(format("K {}", KILLS), 130, 46, 18);
        draw_text(format("EN {}", ENEMIES_ALIVE), 214, 46, 18);
        draw_text(format("SPD {}", spd), 294, 46, 18);

        var hp_ratio = HP / HP_MAX;
        var spd_ratio = math.clamp(spd / 700, 0, 1);

        set_color(220, 230, 250);
        draw_text("HP", 22, 70, 14);
        set_color(24, 28, 36);
        draw_rectangle(54, 72, 130, 10, true);
        set_color(255, 100, 120);
        draw_rectangle(54, 72, 130 * hp_ratio, 10, true);
        set_color(255, 185, 195);
        draw_rectangle(54, 72, 130, 10, false);

        set_color(220, 230, 250);
        draw_text("SPEED", 196, 70, 14);
        set_color(24, 28, 36);
        draw_rectangle(246, 72, 124, 10, true);
        set_color(130, 220, 255);
        draw_rectangle(246, 72, 124 * spd_ratio, 10, true);
        set_color(180, 240, 255);
        draw_rectangle(246, 72, 124, 10, false);

        if (PLAYER_RAPID_TIMER > 0)
        {
            set_color(255, 220, 120);
            draw_text(format("R {}s", int(PLAYER_RAPID_TIMER * 10) / 10), 22, 92, 14);
        }
        if (PLAYER_SHIELD_TIMER > 0)
        {
            set_color(130, 220, 255);
            draw_text(format("S {}s", int(PLAYER_SHIELD_TIMER * 10) / 10), 112, 92, 14);
        }
        if (PLAYER_OVERDRIVE_TIMER > 0)
        {
            set_color(255, 140, 220);
            draw_text(format("O {}s", int(PLAYER_OVERDRIVE_TIMER * 10) / 10), 202, 92, 14);
        }

        if (HUD_HELP_VISIBLE)
        {
            set_alpha(150);
            set_color(8, 10, 16);
            draw_rectangle(12, VIEW_H - 72, 520, 58, true);
            set_alpha(255);
            set_color(180, 200, 235);
            draw_rectangle(12, VIEW_H - 72, 520, 58, false);
            set_color(235, 242, 255);
            draw_text("MOVE: WASD/Arrows | DRIFT: Space | BOOST: Shift | FIRE: Mouse/F", 22, VIEW_H - 62, 15);
            if (TOUCH_UI_ENABLED)
            {
                draw_text("Touch: knob steer | right ACCEL/REVERSE/FIRE | left dpad boost/drift | tap aim", 22, VIEW_H - 40, 15);
            }
            else
            {
                draw_text("Desktop controls active | F1 hide help", 22, VIEW_H - 40, 15);
            }
        }

        draw_joystick();

        if (GAME_OVER)
        {
            set_color(255, 120, 120);
            draw_text("WRECKED! Press R", VIEW_W / 2 - 140, VIEW_H / 2 - 14, 34);
        }

        // Restaura draw em world-space para o frame seguinte.
        set_draw_screen(false);

    if (key_pressed(KEY_R))
    {
  
        start_game();
    }

    if (key_pressed(KEY_F1))
    {
        HUD_HELP_VISIBLE = !HUD_HELP_VISIBLE;
    }

    if (TOUCH_UI_ENABLED && key_pressed(KEY_F2))
    {
        TOUCH_UI_VISIBLE = !TOUCH_UI_VISIBLE;
        vkey_set_visible(TOUCH_UI_VISIBLE);
    }

    if (key_pressed(KEY_ESCAPE))
    {
        let_me_alone();
        break;
    }

    frame;
}
